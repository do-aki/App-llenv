#!/usr/bin/env perl
# DO NOT EDIT -- this is an auto generated file
# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"App/llenv.pm"} = <<'APP_LLENV';
  package App::llenv;
  use 5.008_001;
  use strict;
  use warnings;
  use Getopt::Compact::WithCmd;
  use File::Spec::Functions qw( catfile catdir );
  use File::Path qw( mkpath );
  use Cwd;
  
  our $VERSION = '0.01';
  
  sub new {
      my $class = shift;
      my $self = {};
      bless $self, $class;
  #    $ENV{LLENV_ROOT} = $ENV{LLENV_ROOT} || catdir($ENV{HOME}, 'llenv');
      return $self;
  }
  
  sub init {
      my $self = shift;
  
      if (! -f $self->abs_path('config.pl')) {
          open my $fh, '>', $self->abs_path('config.pl');
          print {$fh} <<"EOF";
  +{
      common => {
          app_dir => 'apps',
          bin_dir => 'bin',
      },
      perl => {
          env_bundle_lib   => 'PERL5OPT',
          env_app_lib      => 'PERL5OPT',
          tmpl_bundle_lib  => 'local/lib/perl5',
          tmpl_bundle_path => 'local/bin',
          tmpl_app_lib     => 'lib',
          tmpl_app_path    => 'bin',
      },
      ruby => {
          env_bundle_lib   => 'GEM_PATH',
          env_app_lib      => 'RUBYLIB',
          tmpl_bundle_lib  => 'vendor/bundle/ruby/1.9.1',
          tmpl_bundle_path => 'vendor/bundle/ruby/1.9.1/bin',
          tmpl_app_lib     => 'lib',
          tmpl_app_path    => 'bin',
      },
      python => {
          env_bundle_lib   => 'PYTHONPATH',
          env_app_lib      => 'PYTHONPATH',
          tmpl_bundle_lib  => 'lib/python2.7/site-packages',
          tmpl_bundle_path => 'bin',
          tmpl_app_lib     => 'lib',
          tmpl_app_path    => 'bin',
      },
      node => {
          env_bundle_lib   => 'NODE_PATH',
          env_app_lib      => 'NODE_PATH',
          tmpl_bundle_lib  => 'node_modules',
          tmpl_bundle_path => 'node_modules/.bin',
          tmpl_app_lib     => 'lib',
          tmpl_app_path    => 'bin',
      },
  };
  EOF
          close $fh;
      }
      $self->{'conf'} = _get_config_pl(catfile($ENV{LLENV_ROOT}, 'config.pl'));
  
      my $app_dir = $self->abs_path($self->{'conf'}->{'common'}->{'app_dir'});
      my $bin_dir = $self->abs_path($self->{'conf'}->{'common'}->{'bin_dir'});
      for my $path ($app_dir, $bin_dir) {
          if (! -d $path) {
              mkpath $path or die("failed to create $path: $!");
          }
      }
  }
  
  sub parse_options {
      my $self = shift;
      
      my $go = Getopt::Compact::WithCmd->new(
          name          => 'llenv',
          version       => $VERSION,
          command_struct => {
              init => {
                  desc        => 'init llenv',
              },
              setup => {
                  options     => [
                      [ [qw/l ll/], 'LL', '=s', undef, { required => 1 } ],
                      [ [qw/v version/], 'LL version', '=s' ],
                  ],
                  desc        => 'setup llenv app dir',
                  args        => 'APP_NAME',
              },
              exec => {
                  desc        => 'exec cwd script',
                  args        => 'SCRIPT_NAME[ -- SCRIPTOPTIONS]',
              },
              install => {
                  desc        => 'install cwd script to bin dir',
                  args        => 'SCRIPT_NAME',
              },
          },
      );
  
      $self->{'go'} = $go;
      $self->{'command'} = $go->command || $go->show_usage;
      $self->{'opts'} = $go->opts;
  }
  
  sub run {
      my($self) = @_;
      $self->can('command_' . $self->{'command'})->($self, @ARGV);
  }
  
  sub command_init {
      my ($self, @args) = @_;
      print <<EOF;
  llenv init
  
  export LLENV_ROOT=$ENV{LLENV_ROOT}
  export PATH=\$LLENV_ROOT/bin:\$PATH
  
  EOF
  }
  
  sub command_install {
      my ($self, @args) = @_;
      $self->{'go'}->show_usage unless(scalar @args == 1);
      my $script = shift @args;
      my ($ll, $script_file, $env) = $self->get_script_env($script);
      $self->set_env($env);
  
      my $bin_dir = $self->{'conf'}->{'common'}->{'bin_dir'};
      if (! -d $self->abs_path($bin_dir)) {
          mkpath $self->abs_path($bin_dir)
              or die "failed to create $bin_dir: $!";
      }
  
      my $abs_script = $self->abs_path($bin_dir, $script);
      my $export_env = join "\n", map { "export $_=\"$env->{$_}\$$_\"" } keys %$env;
      open my $fh, '>', $abs_script;
      print {$fh} <<"EOF";
  #!/bin/sh
  $export_env
  exec /usr/bin/env $ll $script_file "\$@"
  EOF
      close $fh;
      system("chmod +x $abs_script");
  }
  
  sub command_exec {
      my ($self, @args) = @_;
      $self->{'go'}->show_usage if(scalar @args < 1);
      my $script = shift @args;
  
      my ($ll, $script_file, $env) = $self->get_script_env($script);
      $self->set_env($env);
      system("/usr/bin/env $ll $script_file @args");
  }
  
  sub set_env {
      my ($self, $env) = @_;
      my $LLENV_ROOT = $ENV{LLENV_ROOT};
      for (keys %$env) {
          $ENV{$_} = '' unless defined $ENV{$_};
          my $str = eval "qq{$env->{$_}}";
          $ENV{$_} = $str.$ENV{$_};
      }
  }
  
  sub get_script_env {
      my ($self, $script) = @_;
  
      my $llenv_file = catdir(getcwd, '.llenv.pl');
      my $app_conf = _get_config_pl($llenv_file);
      my $ll = (keys %{$app_conf})[0];
      my $conf = $app_conf->{$ll};
  
      my $local_path = $self->get_local_path($conf);
      my $script_file = $self->get_script_path($conf, $script);
      my ($env_bundle_lib, $bundle_lib) = $self->get_bundle_lib($ll, $conf->{'bundle_lib'});
      my ($env_app_lib, $app_lib) = $self->get_app_lib($ll, $conf->{'app_lib'});
      my $env = {
          'PATH' => $local_path,
      };
      $env->{$env_app_lib} .= $app_lib;
      $env->{$env_bundle_lib} .= $bundle_lib;
  
      return ($ll, $script_file, $env);
  }
  
  sub get_script_path {
      my ($self, $conf, $script) = @_;
      for (qw/app_path bundle_path/) {
          next unless(defined $conf->{$_});
          my $full_path = $self->abs_path($conf->{$_}, $script);
          return catfile('$LLENV_ROOT', $conf->{$_}, $script) if(-f $full_path);
      }
      die "not found $script";
  }
  
  sub get_local_path {
      my ($self, $conf) = @_;
      my $path = '';
      for (qw/bundle_path app_path/) {
          next unless(defined $conf->{$_});
          my $_path = catdir('$LLENV_ROOT', $conf->{$_});
          $path = "$_path:$path";
      }
      return $path;
  }
  
  sub get_bundle_lib {
      my ($self, $ll, $lib) = @_;
      my $env_bundle_lib = $self->{'conf'}->{$ll}->{'env_bundle_lib'};
      $lib = catdir('$LLENV_ROOT', $lib);
      if ($ll eq 'perl') {
          $lib = "-Mlib=$lib ";
      } else {
          $lib = "$lib:";
      }
      return ($env_bundle_lib, $lib);
  }
  
  sub get_app_lib {
      my ($self, $ll, $lib) = @_;
      my $env_app_lib = $self->{'conf'}->{$ll}->{'env_app_lib'};
      $lib = catdir('$LLENV_ROOT', $lib);
      if ($ll eq 'perl') {
          $lib = "-Mlib=$lib ";
      } else {
          $lib = "$lib:";
      }
      return ($env_app_lib, $lib);
  }
  
  sub command_setup {
      my ($self, @args) = @_;
      $self->{'go'}->show_usage unless(scalar @args == 1);
      my $app_name = $args[0];
      my $opts = $self->{'opts'};
      my $conf = $self->{'conf'}->{$opts->{'ll'}}
          or die("not found $opts->{'ll'} conf");
  
      my $app_dir = catdir($self->{'conf'}->{'common'}->{'app_dir'}, $app_name);
      my $app_bundle_lib = catdir($app_dir, $conf->{'tmpl_bundle_lib'});
      my $app_bundle_path = catdir($app_dir, $conf->{'tmpl_bundle_path'});
      my $app_lib = catdir($app_dir, $conf->{'tmpl_app_lib'});
      my $app_path = catdir($app_dir, $conf->{'tmpl_app_path'});
  
      if (! -d $self->abs_path($app_dir)) {
          mkpath $self->abs_path($app_dir)
              or die("failed to create $app_dir: $!");
      }
  
      open my $fh, '>', $self->abs_path($app_dir, '.llenv.pl');
      print {$fh} <<"EOF";
  +{
      $opts->{'ll'} => {
          bundle_lib => '$app_bundle_lib',
          bundle_path => '$app_bundle_path',
          app_lib => '$app_lib',
          app_path => '$app_path',
      },
  }
  EOF
      close $fh;
  }
  
  sub abs_path {
      my ($self, @path) = @_;
      return catdir($ENV{LLENV_ROOT}, @path);
  }
  
  sub _get_config_pl {
      my ($fname) = @_;
      my $config = do $fname;
      die("$fname: $@") if $@;
      die("$fname: $!") unless defined $config;
      unless ( ref($config) eq 'HASH' ) {
          die("$fname does not return HashRef.");
      }
      return $config;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  App::llenv - Perl extention to do something
  
  =head1 VERSION
  
  This document describes App::llenv version 0.01.
  
  =head1 SYNOPSIS
  
      use App::llenv;
  
  =head1 DESCRIPTION
  
  # TODO
  
  =head1 INTERFACE
  
  =head2 Functions
  
  =head3 C<< hello() >>
  
  # TODO
  
  =head1 DEPENDENCIES
  
  Perl 5.8.1 or later.
  
  =head1 BUGS
  
  All complex software has bugs lurking in it, and this module is no
  exception. If you find a bug please either email me, or add the bug
  to cpan-RT.
  
  =head1 SEE ALSO
  
  L<perl>
  
  =head1 AUTHOR
  
  riywo E<lt>riywo.jp@gmail.comE<gt>
  
  =head1 LICENSE AND COPYRIGHT
  
  Copyright (c) 2012, riywo. All rights reserved.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
APP_LLENV

$fatpacked{"Getopt/Compact/WithCmd.pm"} = <<'GETOPT_COMPACT_WITHCMD';
  package Getopt::Compact::WithCmd;
  
  use strict;
  use warnings;
  use 5.008_001;
  use Data::Dumper ();
  use List::Util qw(max);
  use Getopt::Long qw(GetOptionsFromArray);
  use Carp ();
  use constant DEFAULT_CONFIG => (no_auto_abbrev => 1, bundling => 1);
  
  our $VERSION = '0.19';
  
  my $TYPE_MAP = {
      'Bool'   => '!',
      'Incr'   => '+',
      'Str'    => '=s',
      'Int'    => '=i',
      'Num'    => '=f',
      'ExNum'  => '=o',
  };
  
  my $TYPE_GEN = {};
  
  sub new {
      my ($class, %args) = @_;
      my $self = bless {
          cmd         => $args{cmd} || do { require File::Basename; File::Basename::basename($0) },
          name        => $args{name},
          version     => $args{version} || $::VERSION,
          modes       => $args{modes},
          opt         => {},
          usage       => exists $args{usage} && !$args{usage} ? 0 : 1,
          args        => $args{args} || '',
          _argv       => \@ARGV,
          struct      => [],
          summary     => {},
          requires    => {},
          ret         => 0,
          error       => undef,
          other_usage => undef,
          commands    => [],
          _struct     => $args{command_struct} || {},
      }, $class;
  
      my %config = (DEFAULT_CONFIG, %{$args{configure} || {}});
      my @gconf = grep $config{$_}, keys %config;
      Getopt::Long::Configure(@gconf) if @gconf;
  
      $self->_init_summary($args{command_struct});
  
      $self->_init_struct($args{global_struct} || []);
      my $opthash = $self->_parse_struct || return $self;
      if ($args{command_struct}) {
          if (my @gopts = $self->_parse_argv) {
              $self->{ret} = $self->_parse_option(\@gopts, $opthash);
              return $self unless $self->{ret};
              return $self if $self->_want_help;
          }
          $self->_check_requires;
      }
      else {
          $self->{ret} = $self->_parse_option(\@ARGV, $opthash);
          return $self unless $self->{ret};
          return $self if $self->_want_help;
          $self->_check_requires;
          return $self;
      }
  
      $self->_parse_command_struct($args{command_struct});
      return $self;
  }
  
  sub new_from_array {
      my ($class, $args, %options) = @_;
      unless (ref $args eq 'ARRAY') {
          Carp::croak("Usage: $class->new_from_array(\\\@args, %options)");
      }
      local *ARGV = $args;
      return $class->new(%options);
  }
  
  sub new_from_string {
      my ($class, $str, %options) = @_;
      unless (defined $str) {
          Carp::croak("Usage: $class->new_from_string(\$str, %options)");
      }
      require Text::ParseWords;
      my $args = [Text::ParseWords::shellwords($str)];
      local *ARGV = $args;
      return $class->new(%options);
  }
  
  sub args       { $_[0]->{_argv}     }
  sub error      { $_[0]->{error}||'' }
  sub command    { $_[0]->{command}   }
  sub commands   { $_[0]->{commands}  }
  sub status     { $_[0]->{ret}       }
  sub is_success { $_[0]->{ret}       }
  sub pod2usage  { Carp::carp('Not implemented') }
  
  sub opts {
      my($self) = @_;
      my $opt = $self->{opt};
      if ($self->{usage} && ($opt->{help} || $self->status == 0)) {
          # display usage message & exit
          print $self->usage;
          exit !$self->status;
      }
      return $opt;
  }
  
  sub usage {
      my($self, @targets) = @_;
      my $usage = '';
      my(@help, @commands);
  
      if ((defined $self->command && $self->command eq 'help') || @targets) {
          delete $self->{command};
          @targets = @{$self->{_argv}} unless @targets;
          for (my $i = 0; $i < @targets; $i++) {
              my $target = $targets[$i];
              last unless defined $target;
              unless (ref $self->{_struct}{$target} eq 'HASH') {
                  $self->{error} = "Unknown command: $target";
                  last;
              }
              else {
                  $self->{command} = $target;
                  push @{$self->{commands}}, $target;
                  $self->_init_struct($self->{_struct}{$target}{options});
                  $self->_extends_usage($self->{_struct}{$target});
  
                  if (ref $self->{_struct}{$target}{command_struct} eq 'HASH') {
                      $self->{_struct} = $self->{_struct}{$target}{command_struct};
                  }
                  else {
                      $self->{summary} = {};
                  }
              }
          }
      }
  
      my($name, $version, $cmd, $struct, $args, $summary, $error, $other_usage) = map
          $self->{$_} || '', qw/name version cmd struct args summary error other_usage/;
  
      $usage .= "$error\n" if $error;
  
      if ($name) {
          $usage .= $name;
          $usage .= " v$version" if $version;
          $usage .= "\n";
      }
  
      if ($self->command && $self->command ne 'help') {
          my $sub_command = join q{ }, @{$self->commands} ? @{$self->commands} : $self->command;
          $usage .= "usage: $cmd $sub_command [options]";
      }
      else {
          $usage .= "usage: $cmd [options]";
          $usage .= ' COMMAND' if keys %$summary;
      }
      $usage .= ($args ? " $args" : '') . "\n\n";
  
      for my $o (@$struct) {
          my ($name_spec, $desc, $arg_spec, $dist, $opts) = @$o;
          $desc = '' unless defined $desc;
          my @onames = $self->_option_names($name_spec);
          my $optname = join
              (', ', map { (length($_) > 1 ? '--' : '-').$_ } @onames);
          $optname = '    '.$optname unless length($onames[0]) == 1;
          my $info = do {
              local $Data::Dumper::Indent = 0;
              local $Data::Dumper::Terse  = 1;
              my $info = [];
              push @$info, $self->_opt_spec2name($arg_spec) || $arg_spec || '';
              push @$info, $opts->{required}        ? "(required)" : '';
              push @$info, defined $opts->{default} ? "(default: ".Data::Dumper::Dumper($opts->{default}).")" : '';
              $info;
          };
          push @help, [ $optname, $info, ucfirst($desc) ];
      }
  
      if (@help) {
          require Text::Table;
          my $sep = \'   ';
          $usage .= "options:\n";
          $usage .= Text::Table->new($sep, '', $sep, '', $sep, '')->load($self->_format_info(@help))->stringify."\n";
      }
  
      if (defined $other_usage && length $other_usage > 0) {
          $other_usage =~ s/\n$//ms;
          $usage .= "$other_usage\n\n";
      }
  
      if (!$self->command || $self->{has_sub_command}) {
          for my $command (sort keys %$summary) {
              push @commands, [ $command, ucfirst $summary->{$command} ];
          }
  
          if (@commands) {
              require Text::Table;
              my $sep = \'   ';
              $usage .= "Implemented commands are:\n";
              $usage .= Text::Table->new($sep, '', $sep, '')->load(@commands)->stringify."\n";
              my $help_command = "$cmd help COMMAND";
              if (@{$self->commands}) {
                  my $sub_commands = join q{ }, @{$self->commands};
                  $help_command = "$cmd $sub_commands COMMAND --help";
              }
              $usage .= "See '$help_command' for more information on a specific command.\n\n";
          }
      }
  
      return $usage;
  }
  
  sub show_usage {
      my $self = shift;
      print $self->usage(@_);
      exit !$self->status;
  }
  
  sub _opt_spec2name {
      my ($self, $spec) = @_;
      my $name = '';
      return $name unless defined $spec;
      my ($type, $dest) = $spec =~ /^[=:]?([!+isof])([@%])?/;
      if ($type) {
          $name =
              $type eq '!' ? 'Bool'  :
              $type eq '+' ? 'Incr'  :
              $type eq 's' ? 'Str'   :
              $type eq 'i' ? 'Int'   :
              $type eq 'f' ? 'Num'   :
              $type eq 'o' ? 'ExNum' : '';
      }
      if ($dest) {
          $name = $dest eq '@' ? "Array[$name]" : $dest eq '%' ? "Hash[$name]" : $name;
      }
      return $name;
  }
  
  sub _format_info {
      my ($self, @help) = @_;
  
      my $type_max     = 0;
      my $required_max = 0;
      my $default_max  = 0;
      for my $row (@help) {
          my ($type, $required, $default) = @{$row->[1]};
          $type_max     = max $type_max, length($type);
          $required_max = max $required_max, length($required);
          $default_max  = max $default_max, length($default);
      }
  
      for my $row (@help) {
          my ($type, $required, $default) = @{$row->[1]};
          my $parts = [];
          for my $stuff ([$type_max, $type], [$required_max, $required], [$default_max, $default]) {
              push @$parts, sprintf '%-*s', @$stuff if $stuff->[0] > 0;
          }
          $row->[1] = join ' ', @$parts;
      }
  
      return @help;
  }
  
  sub _parse_command_struct {
      my ($self, $command_struct) = @_;
      $command_struct ||= {};
  
      my $command_map = { map { $_ => 1 } keys %$command_struct };
      my $command = shift @ARGV;
      unless ($command) {
          $self->{ret} = $self->_check_requires;
          return $self;
      }
  
      unless ($command_map->{help}) {
          $command_map->{help} = 1;
          $command_struct->{help} = {
              args => '[COMMAND]',
              desc => 'show help message',
          };
      }
  
      unless (exists $command_map->{$command}) {
          $self->{error} = "Unknown command: $command";
          $self->{ret} = 0;
          return $self;
      }
  
      $self->{command} ||= $command;
  
      if ($command eq 'help') {
          $self->{ret} = 0;
          delete $self->{error};
          if (defined $ARGV[0] && exists $command_struct->{$ARGV[0]}) {
              my $nested_struct = $command_struct->{$ARGV[0]}{command_struct};
              $self->_init_nested_struct($nested_struct) if $nested_struct;
          }
          return $self;
      }
  
      push @{$self->{commands} ||= []}, $command;
      $self->_init_struct($command_struct->{$command}{options});
      $self->_extends_usage($command_struct->{$command});
      my $opthash = $self->_parse_struct || return $self;
  
      if (my $nested_struct = $command_struct->{$command}{command_struct}) {
          $self->_init_nested_struct($nested_struct);
  
          my @opts = $self->_parse_argv;
          $self->{ret} = $self->_parse_option(\@opts, $opthash);
          $self->_check_requires;
          if ($self->_want_help) {
              delete $self->{error};
              $self->{ret} = 0;
          }
          return $self unless $self->{ret};
          $self->_parse_command_struct($nested_struct);
      }
      else {
          $self->{ret} = $self->_parse_option(\@ARGV, $opthash);
          $self->_check_requires;
          $self->{has_sub_command} = 0;
          if ($self->_want_help) {
              delete $self->{error};
              $self->{ret} = 0;
          }
      }
  
      return $self;
  }
  
  sub _want_help {
      exists $_[0]->{opt}{help} && $_[0]->{opt}{help} ? 1 : 0;
  }
  
  sub _init_nested_struct {
      my ($self, $nested_struct) = @_;
      $self->{summary} = {}; # reset
      $self->_init_summary($nested_struct);
      $self->{has_sub_command} = 1;
  }
  
  sub _parse_option {
      my ($self, $argv, $opthash) = @_;
      local $SIG{__WARN__} = sub {
          $self->{error} = join '', @_;
          chomp $self->{error};
      };
      my $ret = GetOptionsFromArray($argv, %$opthash) ? 1 : 0;
  
      $self->{parsed_opthash} = $opthash;
  
      return $ret;
  }
  
  sub _parse_argv {
      my @opts;
      while (@ARGV) {
          last unless $ARGV[0] =~ /^-/;
          push @opts, shift @ARGV;
      }
      return @opts;
  }
  
  sub _parse_struct {
      my ($self) = @_;
      my $struct = $self->{struct};
  
      my $opthash = {};
      my $default_opthash = {};
      my $default_args = [];
      for my $s (@$struct) {
          my($m, $descr, $spec, $ref, $opts) = @$s;
          my @onames = $self->_option_names($m);
          my($longname) = grep length($_) > 1, @onames;
          my ($type, $cb) = $self->_compile_spec($spec);
          my $o = join('|', @onames).($type||'');
          my $dest = $longname ? $longname : $onames[0];
          $opts ||= {};
          my $destination;
          if (ref $cb eq 'CODE') {
              my $t =
                  substr($type, -1, 1) eq '@' ? 'Array' :
                  substr($type, -1, 1) eq '%' ? 'Hash'  : '';
              if (ref $ref eq 'CODE') {
                  $destination = sub { $ref->($_[0], $cb->($_[1])) };
              }
              elsif (ref $ref) {
                  if (ref $ref eq 'SCALAR' || ref $ref eq 'REF') {
                      $$ref = $t eq 'Array' ? [] : $t eq 'Hash' ? {} : undef;
                  }
                  elsif (ref $ref eq 'ARRAY') {
                      @$ref = ();
                  }
                  elsif (ref $ref eq 'HASH') {
                      %$ref = ();
                  }
                  $destination = sub {
                      if ($t eq 'Array') {
                          if (ref $ref eq 'SCALAR' || ref $ref eq 'REF') {
                              push @{$$ref}, scalar $cb->($_[1]);
                          }
                          elsif (ref $ref eq 'ARRAY') {
                              push @$ref, scalar $cb->($_[1]);
                          }
                          elsif (ref $ref eq 'HASH') {
                              my @kv = split '=', $_[1], 2;
                              die qq(Option $_[0], key "$_[1]", requires a value\n)
                                  unless @kv == 2;
                              $ref->{$kv[0]} = scalar $cb->($kv[1]);
                          }
                      }
                      elsif ($t eq 'Hash') {
                          if (ref $ref eq 'SCALAR' || ref $ref eq 'REF') {
                              $$ref->{$_[1]} = scalar $cb->($_[2]);
                          }
                          elsif (ref $ref eq 'ARRAY') {
                              # XXX but Getopt::Long is $ret = join '=', $_[1], $_[2];
                              push @$ref, $_[1], scalar $cb->($_[2]);
                          }
                          elsif (ref $ref eq 'HASH') {
                              $ref->{$_[1]} = scalar $cb->($_[2]);
                          }
                      }
                      else {
                          if (ref $ref eq 'SCALAR' || ref $ref eq 'REF') {
                              $$ref = $cb->($_[1]);
                          }
                          elsif (ref $ref eq 'ARRAY') {
                              @$ref = (scalar $cb->($_[1]));
                          }
                          elsif (ref $ref eq 'HASH') {
                              my @kv = split '=', $_[1], 2;
                              die qq(Option $_[0], key "$_[1]", requires a value\n)
                                  unless @kv == 2;
                              %$ref = ($kv[0] => scalar $cb->($kv[1]));
                          }
                      }
                  };
              }
              else {
                  $destination = sub {
                      if ($t eq 'Array') {
                          $self->{opt}{$dest} ||= [];
                          push @{$self->{opt}{$dest}}, scalar $cb->($_[1]);
                      }
                      elsif ($t eq 'Hash') {
                          $self->{opt}{$dest} ||= {};
                          $self->{opt}{$dest}{$_[1]} = $cb->($_[2]);
                      }
                      else {
                          $self->{opt}{$dest} = $cb->($_[1]);
                      }
                  };
              }
          }
          else {
              $destination = ref $ref ? $ref : \$self->{opt}{$dest};
          }
          if (exists $opts->{default}) {
              my $value = $opts->{default};
              if (ref $value eq 'ARRAY') {
                  push @$default_args, map {
                      ("--$dest", $_) 
                  } grep { defined $_ } @$value;
              }
              elsif (ref $value eq 'HASH') {
                  push @$default_args, map {
                      (my $key = $_) =~ s/=/\\=/g;
                      ("--$dest" => "$key=$value->{$_}")
                  } grep {
                      defined $value->{$_}  
                  } keys %$value;
              }
              elsif (not ref $value) {
                  if (!$spec || $spec eq '!') {
                      push @$default_args, "--$dest" if $value;
                  }
                  else {
                      push @$default_args, "--$dest", $value if defined $value;
                  }
              }
              else {
                  $self->{error} = "Invalid default option for $dest";
                  $self->{ret} = 0;
              }
              $default_opthash->{$o} = $destination;
          }
          $opthash->{$o} = $destination;
          $self->{requires}{$dest} = $o if $opts->{required};
      }
  
      return if $self->{error};
      if (@$default_args) {
          $self->{ret} = $self->_parse_option($default_args, $default_opthash);
          return unless $self->{ret};
      }
  
      return $opthash;
  }
  
  sub _init_struct {
      my ($self, $struct) = @_;
      $self->{struct} = ref $struct eq 'ARRAY' ? $struct : ref $struct eq 'HASH' ? $self->_normalize_struct($struct) : [];
  
      if (ref $self->{modes} eq 'ARRAY') {
          my @modeopt;
          for my $m (@{$self->{modes}}) {
              my($mc) = $m =~ /^(\w)/;
              push @modeopt, [[$mc, $m], qq($m mode)];
          }
          unshift @$struct, @modeopt;
      }
  
      unshift @{$self->{struct}}, [[qw(h help)], qq(this help message)]
          if $self->{usage} && !$self->_has_option('help');
  }
  
  sub _normalize_struct {
      my ($self, $struct) = @_;
  
      my $result = [];
      for my $option (keys %$struct) {
          my $data = $struct->{$option} || {};
          $data = ref $data eq 'HASH' ? $data : {};
          my $row = [];
          push @$row, [
              $option,
              ref $data->{alias} eq 'ARRAY' ? @{$data->{alias}} :
              defined $data->{alias}        ? $data->{alias}    :  (),
          ];
          push @$row, $data->{desc};
          push @$row, $data->{type};
          push @$row, $data->{dest};
          push @$row, $data->{opts};
          push @$result, $row;
      }
  
      return $result;
  }
  
  sub _compile_spec {
      my ($self, $spec) = @_;
      return if !defined $spec or $spec eq '';
      return $spec if $self->_opt_spec2name($spec);
      my ($type, $cb);
      if ($spec =~ /^(Array|Hash)\[(\w+)\]$/) {
          $type  = $TYPE_MAP->{$2} || Carp::croak("Can't find type constraint '$2'");
          $type .= $1 eq 'Array' ? '@' : '%';
          $cb    = $TYPE_GEN->{$2};
      }
      elsif ($type = $TYPE_MAP->{$spec}) {
          $cb = $TYPE_GEN->{$spec};
      }
      else {
          Carp::croak("Can't find type constraint '$spec'");
      }
      return $type, $cb;
  }
  
  sub add_type {
      my ($class, $name, $src_type, $cb) = @_;
      unless (defined $name && $src_type && ref $cb eq 'CODE') {
          Carp::croak("Usage: $class->add_type(\$name, \$src_type, \$cb)");
      }
      unless ($TYPE_MAP->{$src_type}) {
          Carp::croak("$src_type is not defined src type");
      }
      $TYPE_MAP->{$name} = $TYPE_MAP->{$src_type};
      $TYPE_GEN->{$name} = $cb;
  }
  
  sub _init_summary {
      my ($self, $command_struct) = @_;
      if ($command_struct) {
          for my $key (keys %$command_struct) {
              $self->{summary}{$key} = $command_struct->{$key}->{desc} || '';
          }
      }
      else {
          $self->{summary} = {};
      }
  }
  
  sub _extends_usage {
      my ($self, $command_option) = @_;
      for my $key (qw/args other_usage/) {
          $self->{$key} = $command_option->{$key} if exists $command_option->{$key};
      }
  }
  
  sub _check_requires {
      my ($self) = @_;
      for my $dest (sort keys %{$self->{requires}}) {
          unless (defined $self->{opt}{$dest}) {
              unless (defined ${$self->{parsed_opthash}{$self->{requires}{$dest}}}) {
                  $self->{ret}   = 0;
                  $self->{error} = "`--$dest` option must be specified";
                  return 0;
              }
          }
      }
      return 1;
  }
  
  sub _option_names {
      my($self, $m) = @_;
      my @sorted = sort {
          my ($la, $lb) = (length($a), length($b));
          return $la <=> $lb if $la < 2 or $lb < 2;
          return 0;
      } ref $m eq 'ARRAY' ? @$m : $m;
      return @sorted;
  }
  
  sub _has_option {
      my($self, $option) = @_;
      return 1 if grep { $_ eq $option } map { $self->_option_names($_->[0]) } @{$self->{struct}};
      return 0;
  }
  
  1;
  __END__
  
  =encoding utf-8
  
  =for stopwords
  
  =head1 NAME
  
  Getopt::Compact::WithCmd - sub-command friendly, like Getopt::Compact
  
  =head1 SYNOPSIS
  
  inside foo.pl:
  
    use Getopt::Compact::WithCmd;
    
    my $go = Getopt::Compact::WithCmd->new(
       name          => 'foo',
       version       => '0.1',
       args          => 'FILE',
       global_struct => [
          [ [qw/f force/], 'force overwrite', '!', \my $force ],
       ],
       command_struct => {
          get => {
              options     => [
                  [ [qw/d dir/], 'dest dir', '=s', undef, { default => '.' } ],
                  [ [qw/o output/], 'output file name', '=s', undef, { required => 1 }],
              ],
              desc        => 'get file from url',
              args        => 'url',
              other_usage => 'blah blah blah',
          },
          remove => {
              ...
          }
       },
    );
    
    my $opts = $go->opts;
    my $cmd  = $go->command;
    
    if ($cmd eq 'get') {
        my $url = shift @ARGV;
    }
  
  how will be like this:
  
    $ ./foo.pl -f get -o bar.html http://example.com/
  
  usage, running the command './foo.pl -x' results in the following output:
  
    $ ./foo.pl -x
    Unknown option: x
    foo v0.1
    usage: foo.pl [options] COMMAND FILE
    
    options:
       -h, --help           This help message
       -f, --force   Bool   Force overwrite
    
    Implemented commands are:
       get   Get file from url
    
    See 'foo.pl help COMMAND' for more information on a specific command.
  
  in addition, running the command './foo.pl get' results in the following output:
  
    $ ./foo.pl get
    `--output` option must be specified
    foo v0.1
    usage: foo.pl get [options] url
    
    options:
       -h, --help                                     This help message
       -d, --dir      Str            (default: '.')   Dest dir
       -o, --output   Str (required)                  Output file name
    
    blah blah blah
  
  =head1 DESCRIPTION
  
  Getopt::Compact::WithCmd is yet another Getopt::* module.
  This module is respected L<Getopt::Compact>.
  This module is you can define of git-like option.
  In addition, usage can be set at the same time.
  
  =head1 METHODS
  
  =head2 new(%args)
  
  Create an object.
  The option most Getopt::Compact compatible.
  But I<struct> is cannot use.
  
  The new I<%args> are:
  
  =over
  
  =item C<< global_struct($arrayref) >>
  
  This option is sets common options across commands.
  This option value is Getopt::Compact compatible.
  In addition, extended to other values can be set.
  
    use Getopt::Compact::WithCmd;
    my $go = Getopt::Compact::WithCmd->new(
        global_struct => [
            [ $name_spec_arrayref, $description_scalar, $argument_spec_scalar, \$destination_scalar, $opt_hashref ],
            [ ... ]
        ],
    );
  
  And you can also write in hash style.
  
    use Getopt::Compact::WithCmd;
    my $go = Getopt::Compact::WithCmd->new(
        global_struct => {
            $name_scalar => {
                alias => $name_spec_arrayref,
                desc  => $description_scalar,
                type  => $argument_spec_scalar,
                dest  => \$destination_scalar,
                opts  => $opt_hashref,
            },
            $other_name_scalar => {
                ...
            },
        },
    );
  
  I<$argument_spec_scalar> can be set value are L<< Getopt::Long >>'s option specifications.
  And you can also specify the following readable style:
  
    Bool     # eq !
    Incr     # eq +
    Str      # eq =s
    Int      # eq =i
    Num      # eq =f
    ExNum    # eq =o
  
  In addition, Array and Hash type are:
  
    Array[Str] # eq =s@
    Hash[Int]  # eq =i%
    ...
  
  I<$opt_hasref> are:
  
    {
        default  => $value, # default value
        required => $bool,
    }
  
  =item C<< command_struct($hashref) >>
  
  This option is sets sub-command and options.
  
    use Getopt::Compact::WithCmd;
    my $go = Getopt::Compact::WithCmd->new(
        command_struct => {
            $command => {
                options        => $options,
                args           => $args,
                desc           => $description,
                other_usage    => $other_usage,
                command_struct => $command_struct,
            },
        },
    );
  
  I<$options>
  
  This value is compatible to C<global_struct>.
  
  I<$args>
  
  command args.
  
  I<$description>
  
  command description.
  
  I<$other_usage>
  
  other usage message.
  be added to the end of the usage message.
  
  I<$command_struct>
  
  support nesting.
  
    use Getopt::Compact::WithCmd;
    my $go = Getopt::Compact::WithCmd->new(
        command_struct => {
            $command => {
                options        => $options,
                args           => $args,
                desc           => $description,
                other_usage    => $other_usage,
                command_struct => {
                    $sub_command => {
                        options => ...
                    },
                },
            },
        },
    );
  
    # will run cmd:
    $ ./foo.pl $command $sub_command ...
  
  =back
  
  =head2 add_type($new_type, $src_type, $code_ref);
  
  This method is additional your own type.
  You must be call before new() method.
  
    use JSON;
    use Data::Dumper;
  
    Getopt::Compact::WithCmd->add_type(JSON => Str => sub { decode_json(shift) });
    my $go = Getopt::Compact::WithCmd->new(
        global_struct => {
            from_json => {
                type => 'JSON',
            },
        },
    );
    my $data = $go->opts->{from_json};
    print Dumper $data;
  
    # will run cmd:
    $ ./add_type.pl --from_json '{"foo":"bar"}'
    $VAR1 = {
              'foo' => 'bar'
            };
  
  =head2 new_from_array(\@myopts, %args);
  
  C<< new_from_array >> can be used to parse options from an arbitrary array.
  
    $go = Getopt::Compact::WithCmd->new_from_array(\@myopts, ...);
  
  =head2 new_from_string($option_string, %args);
  
  C<< new_from_string >> can be used to parts options from an arbitrary string.
  
  This method using L<< Text::ParseWords >> on internal.
  
    $go = Getopt::Compact::WithCmd->new_from_string('--foo bar baz', ...);
  
  =head2 opts
  
  Returns a hashref of options keyed by option name.
  Return value is merged global options and command options.
  
  =head2 command
  
  Gets sub-command name.
  
    # inside foo.pl
    use Getopt::Compact::WithCmd;
    
    my $go = Getopt::Compact::WithCmd->new(
       command_struct => {
          bar => {},
       },
    );
    
    print "command: ", $go->command, "\n";
    
    # running the command
    $ ./foo.pl bar
    bar
  
  =head2 commands
  
  Get sub commands. Returned value is ARRAYREF.
  
    # inside foo.pl
    use Getopt::Compact::WithCmd;
    
    my $go = Getopt::Compact::WithCmd->new(
       command_struct => {
          bar => {
              command_struct => {
                  baz => {},
              },
          },
       },
    );
    
    print join(", ", @{$go->commands}), "\n";
    
    # running the command
    $ ./foo.pl bar baz
    bar, baz
  
  =head2 status
  
  This is a true value if the command line was processed successfully. Otherwise it returns a false result.
  
    $go->status ? "success" : "fail";
  
  =head2 is_success
  
  Alias of C<status>
  
    $go->is_success # == $go->status
  
  =head2 usage
  
  Gets usage message.
  
    my $message = $go->usage;
    my $message = $go->usage($target_command_name); # must be implemented command.
  
  =head2 show_usage
  
  Display usage message and exit.
  
    $go->show_usage;
    $go->show_usage($target_command_name);
  
  =head2 error
  
  Return value is an error message or empty string.
  
    $go->error;
  
  =head2 args
  
  Return value is array reference to any remaining arguments.
  
    $go->args # like \@ARGV
  
  =head2 pod2usage
  
  B<Not implemented.>
  
  =head1 AUTHOR
  
  xaicron E<lt>xaicron {at} cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2010 - xaicron
  
  =head1 LICENSE
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<Getopt::Compact>
  
  =cut
GETOPT_COMPACT_WITHCMD

$fatpacked{"Text/Aligner.pm"} = <<'TEXT_ALIGNER';
  # Text::Aligner - Align text in columns
  package Text::Aligner;
  use strict;
  use warnings;
  
  BEGIN    {
      use Exporter ();
      use vars qw ($VERSION @ISA @EXPORT @EXPORT_OK %EXPORT_TAGS);
      $VERSION     = '0.07';
      @ISA         = qw (Exporter);
      @EXPORT      = qw ();
      @EXPORT_OK   = qw ( align);
      %EXPORT_TAGS = ();
  }
  
  # this is a non-method, and currently the only user interface
  sub align ($@) {
      my $ali = Text::Aligner->new( shift);
      $ali->alloc( map ref eq 'SCALAR' ? $$_ : $_, @_);
      if ( defined wantarray ) {
          my @just = map $ali->justify( ref eq 'SCALAR' ? $$_ : $_), @_;
          return @just if wantarray;
          return join "\n", @just, '';
      } else {
          for ( @_ ) {
              $_ = $ali->justify( $_) for ref eq 'SCALAR' ? $$_ : $_; # one-shot
          }
      }
  }
  
  ### class Text::Aligner
  
  sub _new { # internal creator
      my $class = shift;
      my ( $width, $pos) = @_; # both method-or-coderef (this is very general)
      bless {
          width => $width,
          pos => $pos,
          left => Text::Aligner::MaxKeeper->new,
          right => Text::Aligner::MaxKeeper->new,
      }, $class;
  }
  
  # create an aligner
  sub new {
      my ( $class, $spec) = @_;
      $spec ||= 0; # left alignment is default
      my $al;
      if ( !ref( $spec) and $spec =~ s/^auto/num/ ) {
          $al = Text::Aligner::Auto->_new( $spec);
      } else {
          $al = $class->_new( _compile_alispec( $spec));
      }
      $al;
  }
  
  # return left and right field widths for an object
  sub _measure0 {
      my $al = shift;
      my $obj = shift;
      $obj = '' unless defined $obj;
      my ( $w, $p);
      if ( ref $obj ) {
          ( $w, $p) = ( $obj->$al->{ width}->(), $obj->$al->{ pos}->() );
      } else {
          ( $w, $p) = ( $al->{ width}->( $obj), $al->{ pos}->( $obj) );
      }
      $_ ||= 0 for $w, $p;
      ( $p, $w - $p);
  }
  
  use Term::ANSIColor;
  *colorstrip = \ &Term::ANSIColor::colorstrip;
  # early versions of Term::ANSIColor don't have colorstrip
  defined &colorstrip or *colorstrip = sub { shift };
  
  # return left and right field widths for an object
  sub _measure {
      my $al = shift;
      my $obj = shift;
      $obj = '' unless defined $obj;
      my ( $wmeth, $pmeth) = @{ $al}{ qw( width pos)};
  
      # support colorized strings
      $obj = colorstrip($obj) unless ref $obj;
  
      my $w = ref $wmeth ? $wmeth->( $obj) : $obj->$wmeth;
      my $p = ref $pmeth ? $pmeth->( $obj) : $obj->$pmeth;
      $_ ||= 0 for $w, $p;
      ( $p, $w - $p);
  }
  
  # return left and rigth maxima, or nothing if the aligner is empty
  sub _status {
      my @lr = ( $_[ 0]->{ left}->max, $_[ 0]->{ right}->max);
      # $l and $r should be both defined or undefined, unless the
      # MaxKeeper memory is corrupted by forgetting unremembered things.
      return unless defined( $lr[ 0]) and defined( $lr[ 1]);
      @lr;
  }
  
  # remember alignment requirements
  sub alloc {
      my $al = shift;
      for ( @_ ) {
  #       $_ ||= ''; print "allocing '$_'\n";
          my ( $l, $r) = $al->_measure( $_);
          $al->{ left}->remember( $l); # space needed left of pos
          $al->{ right}->remember( $r); # ...and right of pos
      }
      $al;
  }
  
  # release alignment requirement.  it disturbs an aligner deeply to forget
  # things it hasn't remembered.  the effects may be delayed.
  sub _forget {
      my $al = shift;
      for ( map defined() ? $_ : '', @_ ) {
  #       print "forgetting '$_'\n";
          my ( $l, $r) = $al->_measure( $_);
          $al->{ left}->forget( $l);
          $al->{ right}->forget( $r);
      }
      $al;
  }
  
  # justify a string.  a string is aligned within the aligner's field, and
  # filled with blanks or cut to size, as appropriate.  a string that has
  # been allocated will never be trimmed (that is the point of allocation).
  # if the aligner is empty it returns the string unaltered.
  sub justify {
      my $al = shift;
      my $str  = shift;
  #   print "justifying '$str'\n";
      $str .= ''; # stringify (objects, numbers, undef)
      my ( $l_pad, $r_pad) = $al->_padding( $str);
      substr( $str, 0, -$l_pad) = '' if $l_pad < 0; # trim if negative
      substr( $str, $r_pad) = '' if $r_pad < 0; # ... both ends
      join $str, ' ' x $l_pad, ' ' x $r_pad; # pad if positive
  }
  
  # return two numbers that indicate how many blanks are needed on each side
  # of a string to justify it.  Negative values mean trim that many characters.
  # an empty aligner returns ( 0, 0), so doesn't change anything.
  sub _padding {
      my $al = shift;
      my $str = shift;
      my ( $this_l, $this_r) = $al->_measure( $str);
      my ( $l_pad, $r_pad) = ( 0, 0);
      if ( $al->_status ) {
          ( $l_pad, $r_pad) = $al->_status;
          $l_pad -= $this_l;
          $r_pad -= $this_r;
      }
      ( $l_pad, $r_pad);
  }
  
  # _compile_alispec() returns positioners according to specification.  In
  # effect, it is is the interpreter for alignment specifications.
  
  sub _compile_alispec { # it's a dirty job...
      my $width = sub { length shift }; # this is always so for string aligners
      my $pos; # the positioner we actually compile
      local $_ = shift || ''; # alignment specification
      if ( ref() eq 'Regexp' ) { 
          my $regex = $_; # lexical copy!
          $pos = sub {
              local $_ = shift;
              return m/$regex/ ? $-[ 0] : length; # assume match after string
          };
      } else {
          s/^left/0/;
          s/^center/0.5/;
          s/^right/1/;
          if ( _is_number( $_) ) {
              my $proportion = $_; # use lexical copy
              $pos = sub { int( $proportion*length shift) };
          } elsif ( $_ =~ /^(?:num|point)(?:\((.*))?/ ) {
              my $point = defined $1 ? $1 : '';
              $point =~ s/\)$//; # ignore trailing paren, if present
              length $point or $point = '.';
              $pos = sub { index( shift() . $point, $point) }
          } else {
              $pos = sub { 0 };
          }
      }
      ( $width, $pos);
  }
  
  # decide if a string is a number. (see perlfaq4).
  sub _is_number {
      my ($x) = @_;
      return 0 unless defined $x;
      return 0 if $x !~ /\d/;
      return 1 if $x =~ /^-?\d+\.?\d*$/;
      $x = colorstrip($x);
      $x =~ /^-?\d+\.?\d*$/
  }
  
  package Text::Aligner::Auto;
  # Combined numeric and left alignment.  Numbers are aligned numerically,
  # other strings are left-aligned.  The resulting columns are interleaved
  # flush left and filled on the right if necessary.
  
  sub _new { # only called by Text::Aligner->new()
      my $class = shift;
      my $numspec = shift; # currently ignored
      bless {
          num => Text::Aligner->new( 'num'),    # align numbers among themselves
          other => Text::Aligner->new,          # left-align anything else
      }, $class;
  }
  
  sub alloc {
      my $aa = shift;
      my @num = grep _is_number( $_), @_;
      my @other = grep !_is_number( $_), @_;
      $aa->{ num}->alloc( @num);
      $aa->{ other}->alloc( @other);
      $aa;
  }
  
  sub _forget {
      my $aa = shift;
      $aa->{ num}->_forget( grep _is_number( $_), @_);
      $aa->{ other}->_forget( grep !_is_number( $_), @_);
      $aa;
  }
  
  # justify as required
  sub justify {
      my ( $aa, $str) = @_;
      # align according to type
      $str = $aa->{ _is_number( $str) ? 'num' : 'other'}->justify( $str);
      my $combi = Text::Aligner->new; # left-justify pre-aligned string
      # initialise to size of partial aligners.  (don't initialise from
      # empty aligner)
      $combi->alloc( $aa->{ num}->justify( '')) if $aa->{ num}->_status;
      $combi->alloc( $aa->{ other}->justify( '')) if $aa->{ other}->_status;
      $combi->justify( $str);
  }
  
  # for convenience
  BEGIN { # import _is_number()
      *_is_number = \ &Text::Aligner::_is_number;
  }
  
  package Text::Aligner::MaxKeeper;
  # Keep the maximum of a dynamic set of numbers.  Optimized for the case of
  # a relatively small range of numbers that may occur repeatedly.
  
  sub new {
      bless {
          max => undef,
          seen => {},
      }, shift;
  }
  
  sub max { $_[ 0]->{ max} }
  
  sub remember {
      my ( $mk, $val) = @_;
      _to_max( $mk->{ max}, $val);
      $mk->{ seen}->{ $val}++;
      $mk;
  }
  
  sub forget {
      my ( $mk, $val) = @_;
      if ( exists $mk->{ seen}->{ $val} ) {
          my $seen = $mk->{ seen};
          unless ( --$seen->{ $val} ) {
              delete $seen->{ $val};
              if ( $mk->{ max} == $val ) {
                  # lost the maximum, recalculate
                  undef $mk->{ max};
                  _to_max( $mk->{ max}, keys %$seen);
              }
          }
      }
      $mk;
  }
  
  sub _to_max {
      my $var = \ shift;
      defined $_ and ( not defined $$var or $$var < $_) and $$var = $_ for @_;
      $$var;
  }
  
  ########################################### main pod documentation begin ##
  
  =head1 NAME
  
  Text::Aligner
  
  =head1 SYNOPSIS
  
    use Text::Aligner qw( align);
  
    # Print the words "just a test!" right-justified each on a line:
  
    my @lines = align( 'right', qw( just a test!);
    print "$_\n" for @lines;
  
  =head1 DESCRIPTION
  
  Text::Aligner exports a single function, align(), which is
  used to justify strings to various alignment styles.  The
  alignment specification is the first argument, followed by
  any number of scalars which are subject to alignment.
  
  The operation depends on context.  In list context, a list of
  the justified scalars is returned.  In scalar context, the
  justified arguments are joined into a single string with newlines
  appended.  The original arguments remain unchanged.  In void
  context, in-place justification is attempted.  In this case, all
  arguments must be lvalues.
  
  Align() also does one level of scalar dereferencing.  That is,
  whenever one of the arguments is a scalar reference, the scalar
  pointed to is aligned instead.  Other references are simply stringified.
  An undefined argument is interpreted as an empty string without
  complaint.
  
  Alignment respects colorizing escape sequences a la Term::ANSICOLOR,
  which means it knows that thses sequences don't take up space on
  the screen.
  
  =head1 ALIGNMENT
  
  The first argument of the align() function is an alignment style, a
  single scalar.
  
  It can be one of the strings "left", "right", "center", "num", "point",
  or "auto", or a regular expression (qr/.../), or a coderef.
  
  A default style of "left" is assumed for every other value, including
  "" and undef. 
  
  "left", "right" and "center" have the obvious meanings.  These can
  also be given as numbers 0, 1, and 0.5 respectively. (Other numbers
  are also possible, but probably not very useful).
  
  "num", and its synonym "point", specify that the decimal points be
  aligned (assumed on the right, unless present).  Arbitrary (non-numeric)
  strings are also aligned in this manner, so they end up one column left
  of the (possibly assumed) decimal point, flush right with any integers. 
  For the occasional string like "inf", or "-" for missing values, this
  may be the right place.  A string-only column ends up right-aligned
  (unless there are points present).
  
  The "auto" style separates numeric strings (that are composed of
  "-", ".", and digits in the usual manner) and aligns them numerically.
  Other strings are left aligned with the number that sticks out
  farthest to the left.  This gives left alignment for string-only
  columns and numeric alignment for columns of numbers.  In mixed
  columns, strings are reasonably placed to serve as column headings
  or intermediate titles.
  
  With "num" (and "point") it is possible to specify another character
  for the decimal point in the form "num(,)".  In fact, you can specify
  any string after a leading "(", and the closing ")" is optional.
  "point(=>)" could be used to align certain pieces of Perl code.  This
  option is currently not available with "auto" alignment (because
  recognition of numbers is Anglo-centric).
  
  If a regular expression is specified, the points are aligned where
  the first match of the regex starts.  A match is assumed immediately
  after the string if it doesn't match.
  
  A regular expression is a powerful way of alignment specification.  It
  can replace most others easily, except center alignment and, of course,
  the double action of "auto".
  
  =head1 POSITIONERS
  
  For entirely self-defined forms of alignment, a coderef, also known
  as a positioner, can be given instead of an alignment style.  This
  code will be called once or more times with the string to be aligned
  as its argument.  It must return two numbers, a width and a position,
  that describe how to align a string with other strings.
  
  The width should normally be the length of the string.  The position
  defines a point relative to the beginning of the string, which is
  aligned with the positions given for other strings.
  
  A zero position for all strings results in left alignment, positioning
  to the end of the string results in right alignment, and returning
  half the length gives center alignment.  "num" alignment is realized
  by marking the position of the decimal point.
  
  Note that the position you return is a relative measure.  Adding a
  constant value to all positions results in no change in alignment.
  It doesn't have to point inside the string (as in right alignment,
  where it points one character past the end of the string).
  
  The first return value of a positioner should almost always be the
  length of the given string.  It may be useful to ly about the string
  length if the string contains escape sequences that occupy no place
  on screen.
  
  =head1 USAGE
  
    use Text::Aligner qw( align);
  
    align( $style, $str, ...);
  
    $style must be given and must be an alignment specification.
    Any number of scalars can follow.  An argument that contains a
    scalar reference is dereferenced before it is used.  In scalar
    and list context, the aligned strings are returned.  In void
    context, the values are aligned in place and must be lvalues.
  
  =head1 BUGS
  
    None known as of realease, but...
  
  =head1 AUTHOR
  
      Anno Siegel
      CPAN ID: ANNO
  
  =head1 COPYRIGHT
  
  Copyright (c) 2002 Anno Siegel. All rights reserved.
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =head1 SEE ALSO
  
  perl(1)
  
  Text::Table
  
  =cut
  
  1; #this line is important and will help the module return a true value
  __END__
TEXT_ALIGNER

$fatpacked{"Text/Table.pm"} = <<'TEXT_TABLE';
  # Text::Table - Organize Data in Tables
  package Text::Table;
  
  use strict;
  use warnings;
  
  use List::Util qw(sum max);
  
  use Text::Aligner qw(align);
  
  BEGIN {
      our $VERSION = '1.124';
  }
  
  use overload
      '""'  => 'stringify',
  ;
  
  ### User interface:  How to specify columns and column separators
  
  sub _is_sep {
      my $datum = shift;
  
      return 
      (
          defined($datum) 
              and
          (
              (ref($datum) eq 'SCALAR')
                      or
              (ref($datum) eq 'HASH' and $datum->{is_sep})
          )
      );
  }
  
  sub _get_sep_title_body
  {
      my $sep = shift;
  
      return
          +( ref($sep) eq 'HASH' )
          ? @{ $sep }{qw(title body)}
          : split( /\n/, ${$sep}, -1 ) ;
  }
  
  sub _parse_sep {
      my $sep = shift;
  
      if (!defined($sep))
      {
          $sep = '';
      }
  
      my ($title, $body) = _get_sep_title_body($sep);
  
      if (!defined($body))
      {
          $body = $title;
      }
  
      ($title, $body) = align( 'left', $title, $body);
  
      return
      {
          is_sep => 1,
          title  => $title,
          body   => $body,
      };
  }
  
  sub _default_if_empty
  {
      my ($ref, $default) = @_;
  
      if (! (defined($$ref) && length($$ref)))
      {
          $$ref = $default;
      }
  
      return;
  }
  
  sub _is_align
  {
      my $align = shift;
  
      return $align =~ /\A(?:left|center|right)/;
  }
  
  sub _parse_spec {
      my $spec = shift;
  
      if (!defined($spec))
      {
          $spec = '';
      }
  
      my $alispec = qr/^ *(?:left|center|right|num|point|auto)/;
      my ( $title, $align, $align_title, $align_title_lines, $sample);
      if ( ref eq 'HASH' ) {
          ( $title, $align, $align_title, $align_title_lines, $sample) =
              @{$spec}{qw( title align align_title align_title_lines sample )};
      } else {
          my $alispec = qr/&(.*)/;
          if ( $spec =~ $alispec ) {
              ($title, $align, $sample) = ($spec =~ /(.*)^$alispec\n?(.*)/sm);
          } else {
              $title = $spec;
          }
          defined and chomp for $title, $sample;
      }
  
      # Assign default values.
      foreach my $x ($title, $sample)
      {
          if (!defined($x))
          {
              $x = [];
          }
          elsif (ref($x) ne 'ARRAY')
          {
              $x = [ split /\n/, $x, -1];
          }
      }
  
      _default_if_empty(\$align, 'auto');
  
      unless (
          ref $align eq 'Regex' or
          $align =~ /^(?:left|center|right|num\(?|point\(?|auto)/
      ) {
          _warn( "Invalid align specification: '$align', using 'auto'");
          $align = 'auto';
      }
      
      _default_if_empty(\$align_title, 'left');
  
      if ( ! _is_align($align_title) ) {
          _warn( "Invalid align_title specification: " .
              "'$align_title', using 'left'",
          );
          $align_title = 'left';
      }
      
      _default_if_empty(\$align_title_lines, $align_title);
  
      if ( ! _is_align($align_title_lines) ) {
          _warn( "Invalid align_title_lines specification: " .
              "'$align_title_lines', using 'left'",
          );
          $align_title_lines = 'left';
      }
  
      return
      {
          title             => $title,
          align             => $align,
          align_title       => $align_title,
          align_title_lines => $align_title_lines,
          sample            => $sample,
      };
  }
  
  ### table creation
  
  sub new
  {
      my $tb = bless {}, shift;
  
      return $tb->_entitle( @_);
  }
  
  sub _blank
  {
      my $self = shift;
  
      if (@_)
      {
          $self->{blank} = shift;
      }
  
      return $self->{blank};
  }
  
  sub _cols
  {
      my $self = shift;
  
      if (@_)
      {
          $self->{cols} = shift;
      }
  
      return $self->{cols};
  }
  
  sub _forms
  {
      my $self = shift;
  
      if (@_)
      {
          $self->{forms} = shift;
      }
  
      return $self->{forms};
  }
  
  sub _lines
  {
      my $self = shift;
  
      if (@_)
      {
          $self->{lines} = shift;
      }
  
      return $self->{lines};
  }
  
  sub _spec
  {
      my $self = shift;
  
      if (@_)
      {
          $self->{spec} = shift;
      }
  
      return $self->{spec};
  }
  
  sub _titles
  {
      my $self = shift;
  
      if (@_)
      {
          $self->{titles} = shift;
      }
  
      return $self->{titles};
  }
  
  sub _entitle {
      my $tb = shift; # will be completely overwritten
      # find active separators and, well separate them from col specs.
      # n+1 separators for n cols
      my ( @seps, @spec); # separators and column specifications
      my $sep;
      for ( @_ ) {
          if ( _is_sep ( $_) ) {
              $sep = _parse_sep( $_);
          } else {
              push @seps, $sep;
              push @spec, _parse_spec( $_);
              undef $sep;
          }
      }
      push @seps, $sep;
      # build sprintf formats from separators
      my $title_form = _compile_field_format('title', \@seps);
      my $body_form = _compile_field_format('body', \@seps);
  
      # pre_align titles
      my @titles = map { [ @{ $_->{title} } ] } @spec;
  
      my $title_height = max(0, map { scalar(@$_) } @titles);
  
      foreach my $title (@titles)
      {
          push @{$title}, ( '') x ( $title_height - @{$title});
      }
  
      foreach my $t_idx (0 .. $#titles)
      {
          align($spec[$t_idx]->{align_title_lines}, @{$titles[$t_idx]});
      }
  
      # build data structure
      $tb->_spec(\@spec);
      $tb->_cols([ map [], 1 .. @spec]);
      $tb->_forms([ $title_form, $body_form]); # separators condensed
      $tb->_titles(\@titles);
  
      $tb->_clear_cache;
  
      return $tb;
  }
  
  # sprintf-format for line assembly, using separators
  sub _compile_format {
     my $seps = shift; # mix of strings and undef (for default)
  
     for my $idx (0 .. $#$seps)
     {
          if (!defined($seps->[$idx]))
          {
              $seps->[$idx] = ($idx == 0 or $idx == $#$seps) ? '' : q{ };
          }
          else
          {
              # protect against sprintf
              $seps->[$idx] =~ s/%/%%/g;
          }
     }
     return join '%s', @$seps;
  }
  
  sub _compile_field_format
  {
      my ($field, $seps) = @_;
  
      return _compile_format(
          [map { defined($_) ? $_->{$field} : undef } @$seps] 
      );
  }
  
  # reverse format compilation (used by colrange())
  sub _recover_separators {
      my $format = shift;
      my @seps = split /(?<!%)%s/, $format, -1;
      s/%%/%/g for @seps;
      return \@seps;
  }
  
  # select some columns, (optionally if in [...]), and add new separators
  # (the other table creator)
  sub select {
      my $tb = shift;
      my @args = map $tb->_select_group( $_), @_;
      # get column selection, checking indices (some have been checked by
      # _select_group, but not all)
      my @sel = map $tb->_check_index( $_), grep !_is_sep( $_), @args;
      # replace indices with column spec to create subtable
      for my $arg (@args)
      {
          if (! _is_sep($arg))
          {
              $arg = $tb->_spec->[ $arg];
          }
      }
      my $sub = ref( $tb)->new( @args);
      # sneak in data columns
      @{ $sub->{ cols}} = map { [ @$_ ] } @{ $tb->_cols}[ @sel];
      $sub;
  }
  
  # the first non-separator column in the group is tested if it has any data
  # if so, the group is returned, else nothing
  sub _select_group {
      my ( $tb, $group) = @_;
      return $_ unless ref $group eq 'ARRAY';
      for ( @$group ) {
          next if _is_sep( $_);
          $tb->_check_index( $_);
          return @$group if grep $_, @{ $tb->_cols->[ $_]};
          return; # no more tries after non-sep was found
      }
      return; # no column index in group, no select
  }
  
  # check index for validity, return arg if returns at all
  sub _check_index {
      my $tb = shift;
      my ( $i) = @_;
      my $n = $tb->n_cols;
      my $ok = eval {
          use warnings FATAL => 'numeric';
          -$n <= $i and $i < $n; # in range of column array?
      };
      _warn( "Invalid column index '$_'") if $@ or not $ok;
      shift;
  }
  
  ### data entry
  
  sub _clear_cache { 
      my ($tb) = @_;
      
      $tb->_blank(undef());
      $tb->_lines(undef());
  
      return;
  }
  
  # add one data line or split the line into follow-up lines
  sub add {
      my $tb = shift;
      $tb->_entitle( ( '') x @_) unless $tb->n_cols;
  
      $tb->_add( @$_) for 
          _transpose( 
              [
                  map { [ defined() ? split( /\n/ ) : '' ] } @_
              ]
          );
      $tb->_clear_cache;
  
      return $tb;
  }   
  
  # add one data line
  sub _add {
      my $tb = shift;
  
      push @$_, shift for @{ $tb->_cols};
  
      $tb->_clear_cache;
  
      return $tb;
  }
  
  # add one or more data lines
  sub load {
      my $tb = shift;
      for ( @_ ) {
          defined $_ or $_ = '';
          ref eq 'ARRAY' ? $tb->add( @$_) : $tb->add( split);
      }
      $tb;
  }
  
  sub clear {
      my $tb = shift;
  
      foreach my $col (@{ $tb->_cols} )
      {
          $col = [];
      }
  
      $tb->_clear_cache;
  
      return $tb;
  }
  
  ### access to output area
  
  ## sizes
  
  # number of table clolumns
  sub n_cols { scalar @{ $_[0]->{ spec}} }
  
  # number of title lines
  sub title_height { $_[ 0]->n_cols and scalar @{ $_[ 0]->_titles->[ 0]} }
  
  # number of data lines
  sub body_height
  { 
      my ($tb) = @_;
  
      return ($tb->n_cols && scalar @{ $tb->_cols->[0] });
  }
  
  # total height
  sub table_height
  { 
      my $tb = shift;
      return $tb->title_height + $tb->body_height;
  }
  
  BEGIN { *height = \&table_height; } # alias
  
  # number of characters in each table line. need to build the table to know
  sub width
  {
      my ($tb) = @_;
  
      return $tb->height && (length( ($tb->table(0))[0] ) - 1);
  }
  
  sub _normalize_col_index
  {
      my ($tb, $col_index) = @_;
  
      $col_index ||= 0;
  
      if ($col_index < 0)
      {
          $col_index += $tb->n_cols;
      }
  
      if ($col_index < 0)
      {
          $col_index = 0;
      }
      elsif ($col_index > $tb->n_cols)
      {
          $col_index = $tb->n_cols;
      }
  
      return $col_index;
  }
  
  # start and width of each column
  sub colrange {
      my ( $tb, $proto_col_index) = @_;
  
      my $col_index = $tb->_normalize_col_index($proto_col_index);
  
      return ( 0, 0) unless $tb->width; # width called, $tb->_blank() exists now
      my @widths = map { length } @{ $tb->_blank}, '';
      @widths = @widths[ 0 .. $col_index];
  
      my $width = pop @widths;
      my $pos = sum(@widths) || 0;
  
      my $seps_aref = _recover_separators( $tb->_forms->[ 0]);
  
      my $sep_sum = 0;
      foreach my $sep (@$seps_aref[ 0 .. $col_index])
      {
          $sep_sum += length($sep);
      }
  
      return ( $pos+$sep_sum, $width ) ;
  }
  
  ## printable output
  
  # whole table
  sub table {
      my $tb = shift;
  
      return $tb->_table_portion( $tb->height, 0, @_);
  }
  
  # only titles
  sub title {
      my $tb = shift;
  
      return $tb->_table_portion( $tb->title_height, 0, @_);
  }   
  
  # only body
  sub body {
      my $tb = shift;
  
      return $tb->_table_portion( $tb->body_height, $tb->title_height, @_);
  }
  
  sub stringify
  { 
      my ($tb) = @_;
  
      return (scalar ( $tb->table() ));
  }
  
  ### common internals
  
  # common representation of table(), title() and body()
  
  sub _table_portion_as_aref
  {
      my $tb = shift;
  
      my $total = shift;
      my $offset = shift;
  
      my ( $from, $n) = ( 0, $total); # if no parameters
  
      if ( @_ ) {
          $from = shift;
          $n = @_ ? shift : 1; # one line if not given
      }
  
      ( $from, $n) = _limit_range( $total, $from, $n);
  
      my $limit = $tb->title_height; # title format below
      $from += $offset;
  
      return
      [
          map $tb->_assemble_line( $_ >= $limit, $tb->_table_line( $_), 0),
          $from .. $from + $n - 1
      ];
  }
  
  sub _table_portion
  {
      my $tb = shift;
  
      my $lines_aref = $tb->_table_portion_as_aref(@_);
  
      return (wantarray ? @$lines_aref : join('', @$lines_aref));
  }
  
  sub _limit_range
  {
      my ( $total, $from, $n) = @_;
  
      $from ||= 0;
      $from += $total if $from < 0;
      $n = $total unless defined $n;
  
      return ( 0, 0) if $from + $n < 0 or $from >= $total;
  
      $from = 0 if $from < 0;
      $n = $total - $from if $n > $total - $from;
  
      return( $from, $n);
  }
  
  # get table line (formatted, including titles). fill cache if needed
  sub _table_line {
      my ($tb, $idx) = @_;
  
      if (! $tb->_lines)
      {
          $tb->_lines([ $tb->_build_table_lines ]);
      }
  
      return $tb->_lines->[$idx];
  }
  
  # build array of lines of justified data items
  sub _build_table_lines {
      my $tb = shift;
  
      # copy data columns, replacing undef with ''
      my @cols =
          map
          { [ map { defined($_) ? $_ : '' } @$_ ] }
          @{ $tb->_cols() } ;
  
      # add set of empty strings for blank line (needed to build horizontal rules)
      foreach my $col (@cols)
      {
          push @$col, '';
      }
  
      # add samples for minimum alignment
      foreach my $col_idx (0 .. $#cols)
      {
          push @{$cols[$col_idx]}, @{$tb->_spec->[$col_idx]->{sample}};
      }
  
      # align to style
      foreach my $col_idx (0 .. $#cols)
      {
          align($tb->_spec->[$col_idx]->{align}, @{$cols[$col_idx]});
      }
  
      # trim off samples, but leave blank line
      foreach my $col (@cols)
      {
          splice( @{$col}, 1 + $tb->body_height );
      }
  
      # include titles
      foreach my $col_idx (0 .. $#cols)
      {
          unshift @{$cols[$col_idx]}, @{$tb->_titles->[$col_idx]};
      }
  
      # align title and body portions of columns
      # blank line will be there even with no data
      foreach my $col_idx (0 .. $#cols)
      {
          align($tb->_spec->[$col_idx]->{align_title}, @{$cols[$col_idx]});
      }
  
      # deposit a blank line, pulling it off the columns.
      # *_rule() knows this is done
      my @blank;
  
      foreach my $col (@cols)
      {
          push @blank, pop(@$col);
      }
  
      $tb->_blank(\@blank);
  
      return _transpose_n( $tb->height, \@cols); # bye-bye, @cols
  }
  
  # destructively transpose a number of lines/cols from an array of arrayrefs 
  sub _transpose_n {
      my ($n, $cols) = @_;
  
      return map { [ map { shift @$_ } @$cols] } 1 .. $n;
  }
  
  # like _transpose_n, but find the number to transpose from max of given
  sub _transpose
  {
      my ($cols) = @_;
  
      my $m = max ( map { scalar(@$_) } @$cols, []);
  
      return _transpose_n( $m, $cols);
  }
  
  # make a line from a number of formatted data elements
  sub _assemble_line {
      my ($tb, $in_body, $line_aref, $replace_spaces) = @_;
  
      my $format = $tb->_forms->[ !!$in_body];
  
      if ($replace_spaces)
      {
          $format =~ s/\s/=/g;
      }
  
      return sprintf($format, @$line_aref) . "\n";
  }
  
  sub _text_rule
  {
      my ($tb, $rule, $char, $alt) = @_;
  
      # replace blanks with $char. If $alt is given, replace nonblanks
      # with $alt
      if ( defined $alt )
      {
          $rule =~ s/(.)/$1 eq ' ' ? $char : $alt/ge;
      }
      else
      {
          $rule =~ s/ /$char/g if $char ne ' ';
      }
  
      return $rule;
  }
  
  # build a rule line
  sub _rule {
      my $tb = shift;
  
      return + (!$tb->width) ? '' : $tb->_positive_width_rule(@_);
  }
  
  sub _positive_width_rule
  {
      my ($tb, $in_body, $char, $alt) = @_;
  
      my $rule = $tb->_assemble_line( $in_body, $tb->_blank,
          ((ref($char) eq "CODE") ? 1 : 0),
      );
  
      return $tb->_render_rule($rule, $char, $alt);
  }
  
  sub _render_rule
  {
      my ($tb, $rule, $char, $alt) = @_;
  
      if (ref($char) eq "CODE")
      {
          return $tb->_render_rule_with_callbacks($rule, $char, $alt);
      }
      else
      {
          _default_if_empty(\$char, ' ');
  
          return $tb->_text_rule($rule, $char, $alt);
      }
  }
  
  sub _get_fixed_len_string
  {
      my ($s, $len) = @_;
  
      $s  = substr($s, 0, $len);
      $s .= ' ' x ($len - length($s));
  
      return $s;
  }
  
  sub _render_rule_with_callbacks
  {
      my ($tb, $rule, $char, $alt) = @_;
  
      my %callbacks =
      (
          'char' => { cb => $char, idx => 0, },
          'alt' => { cb => $alt, idx => 0, },
      );
  
      my $calc_substitution = sub {
          my $s = shift;
  
          my $len = length($s);
  
          my $which = (($s =~ /\A /) ? 'char' : 'alt');
          my $rec = $callbacks{$which};
  
          return _get_fixed_len_string(
              scalar ($rec->{cb}->($rec->{idx}++, $len)),
              $len,
          );
      };
  
      $rule =~ s/((.)\2*)/$calc_substitution->($1)/ge;
  
      return $rule;
  }
  
  sub rule {
      my $tb = shift;
      return $tb->_rule( 0, @_);
  }
  
  sub body_rule {
      my $tb = shift;
      return $tb->_rule( 1, @_);
  }
  
  ### warning behavior
  use Carp;
  
  {
      my ( $warn, $fatal) = ( 0, 0);
  
      sub warnings
      {
          # Ignore the class/object.
          my (undef, $toggle) = @_;
  
          $toggle ||= 'on';
          if ( $toggle eq 'off' )
          {
              ($warn, $fatal) = (0, 0);
          }
          elsif ( $toggle eq 'fatal' )
          {
              ($warn, $fatal) = (1, 1);
          }
          else
          {
              ($warn, $fatal) = (1, 0);
          }
          return $fatal ? 'fatal' : $warn ? 'on' : 'off';
      }
  
      sub _warn
      {
          my $msg = shift;
  
          return unless $warn;
  
          if ($fatal)
          {
              croak( $msg)
          }
  
          carp( $msg);
  
          return;
      }
  }
  
  __END__
  ########################################### main pod documentation begin ##
  
  =head1 NAME
  
  Text::Table - Organize Data in Tables
  
  =head1 SYNOPSIS
  
      use Text::Table;
      my $tb = Text::Table->new(
          "Planet", "Radius\nkm", "Density\ng/cm^3"
      );
      $tb->load(
          [ "Mercury", 2360, 3.7 ],
          [ "Venus", 6110, 5.1 ],
          [ "Earth", 6378, 5.52 ],
          [ "Jupiter", 71030, 1.3 ],
      );
      print $tb;
  
  This prints a table from the given title and data like this:
  
    Planet  Radius Density
            km     g/cm^3 
    Mercury  2360  3.7    
    Venus    6110  5.1    
    Earth    6378  5.52   
    Jupiter 71030  1.3    
  
  Note that two-line titles work, and that the planet names are aligned
  differently than the numbers.
  
  =head1 DESCRIPTION
  
  Organization of data in table form is a time-honored and useful
  method of data representation.  While columns of data are trivially
  generated by computer through formatted output, even simple tasks
  like keeping titles aligned with the data columns are not trivial,
  and the one-shot solutions one comes up with tend to be particularly
  hard to maintain.  Text::Table allows you to create and maintain
  tables that adapt to alignment requirements as you use them.
  
  =head2 Overview
  
  The process is simple: you create a table (a Text::Table object) by
  describing the columns the table is going to have.  Then you load
  lines of data into the table, and finally print the resulting output
  lines.  Alignment of data and column titles is handled dynamically
  in dependence on the data present.
  
  =head2 Table Creation
  
  In the simplest case, if all you want is a number of (untitled) columns,
  you create an unspecified table and start adding data to it.  The number
  of columns is taken from the first line of data.
  
  To specify a table you specify its columns.  A column description
  can contain a title and alignment requirements for the data, both
  optional.  Additionally, you can specify how the title is aligned with
  the body of a column, and how the lines of a multiline title are
  aligned among themselves.
  
  The columns are collected in the table in the
  order they are given.  On data entry, each column corresponds to
  one data item, and in column selection columns are indexed left to
  right, starting from 0.
  
  Each title can be a multiline string which will be blank-filled to
  the length of the longest partial line.  The largest number of title
  lines in a column determines how many title lines the table has as a
  whole, including the case that no column has any titles.
  
  On output, Columns are separated by a single blank.  You can control
  what goes between columns by specifying separators between (or before,
  or after) columns.  Separators don't contain any data and don't count
  in column indexing.  They also don't accumulate: in a sequence of only
  separators and no columns, only the last one counts.
  
  =head2 Status Information
  
  The width (in characters), height (in lines), number of columns, and
  similar data about the table is available.
  
  =head2 Data Loading
  
  Table data is entered line-wise, each time specifying data entries
  for all table columns.  A bulk loader for many lines at once is also
  available.  You can clear the data from the table for re-use (though
  you will more likely just create another table).
  
  Data can contain colorizing escape sequences (as provided by
  C<Term::AnsiColor>) without upsetting the alignment.
  
  =head2 Table Output
  
  The output area of a table is divided in the title and the body.
  
  The title contains the combined titles from the table columns, if
  any.  Its content never changes with a given table, but it may be
  spread out differently on the page through alignment with the data.
  
  The body contains the data lines, aligned column-wise as specified,
  and left-aligned with the column title.
  
  Each of these is arranged like a Perl array (counting from 0) and can
  be accessed in portions by specifying a first line and the number
  of following lines.  Also like an array, giving a negative first line
  counts from the end of the area.  The whole table, the title followed
  by the body, can also be accessed in this manner.
  
  The subdivisions are there so you can repeat the title (or parts of
  it) along with parts of the body on output, whether for screen paging
  or printout.
  
  A rule line is also available, which is the horizontal counterpart to
  the separator columns you specify with the table.
  It is basically a table line as it would appear if all data entries
  in the line were empty, that is, a blank line except for where the
  column separators have non-blank entries.  If you print it between
  data lines, it will not disrupt the vertical separator structure
  as a plain blank line would.  You can also request a solid rule
  consisting of any character, and even one with the non-blank column
  separators replaced by a character of your choice.  This way you can
  get the popular representation of line-crossings like so:
  
        |
    ----+---
        |
  
  =head2 Warning Control
  
  On table creation, some parameters are checked and warnings issued
  if you allow warnings.  You can also turn warnings into fatal errors.
  
  =head1 SPECIFICATIONS
  
  =head2 Column Specification
  
  Each column specification is a single scalar.  Columns can be either proper
  data columns or column separators.  Both can be specified either as
  (possibly multi-line) strings, or in a more explicit form as hash-refs.
  In the string form, proper columns are given as plain strings, and
  separators are given as scalar references to strings.  In hash form,
  separators have a true value in the field C<is_sep> while proper columns
  don't have this field.
  
  =over 4
  
  =item Columns as strings
  
  A column is given as a column title (any number of lines),
  optionally followed by alignment requirements.  Alignment requirements
  start with a line that begins with an ampersamd "&".  However, only the
  last such line counts as such, so if you have title lines that begin
  with "&", just append an ampersand on a line by itself as a dummy
  alignment section if you don't have one anyway.
  
  What follows the ampersand on its line is the alignment style (like
  I<left>, I<right>, ... as described in L<"Alignment">), you want for
  the data in this column.  If nothing follows, the general default I<auto>
  is used.  If you specify an invalid alignment style, it falls back to
  left alignment.
  
  The lines that follow can contain sample data for this column.  These
  are considered for alignment in the column, but never actually appear
  in the output.  The effect is to guarantee a minimum width for the
  column even if the current data doesn't require it.  This helps dampen
  the oscillations in the appearance of dynamically aligned tables.
  
  =item Columns as Hashes
  
  The format is
  
      {
          title   => $title,
          align   => $align,
          sample  => $sample,
          align_title => $align_title,
          align_title_lines => $align_title_lines,
      }
  
  $title contains the title lines and $sample the sample data.  Both can
  be given as a string or as an array-ref to the list of lines.  $align contains
  the alignment style (without a leading ampersand), usually as a string.
  You can also give a regular expression here, which specifies regex alignment.
  A regex can only be specified in the hash form of a colunm specification.
  
  In hash form you can also specify how the title of a column is aligned
  with its body.  To do this, you specify the keyword C<align_title> with
  C<left>, C<right> or C<center>.  Other alignment specifications are not
  valid here.  The default is C<left>.
  
  C<align_title> also specifies how the lines of a multiline title are
  aligned among themselves.  If you want a different alignment, you
  can specify it with the key C<align_title_lines>.  Again, only C<left>,
  C<right> or C<center> are allowed.
  
  Do not put other keys than those mentioned above (I<title>, I<align>,
  I<align_title>, I<align_title_lines>, and I<sample>) into a hash that
  specifies a column.  Most would be ignored, but some would confuse the
  interpreter (in particular, I<is_sep> has to be avoided).
  
  =item Separators as strings
  
  A separator must be given as a reference to a string (often a literal,
  like C<\' | '>), any string that is given directly describes a column.
  
  It is usually just a (short) string that will be printed between
  table columns on all table lines instead of the default single
  blank.  If you specify two separators (on two lines), the first one
  will be used in the title and the other in the body of the table.
  
  =item Separators as Hashes
  
  The hash representation of a separator has the format
  
      {
          is_sep => 1,
          title  => $title,
          body   => $body,
      }
  
  $title is the separator to be used in the title area and $body
  the one for the body.  If only one is given, the other is used for
  both.  If none is given, a blank is used.  If one is shorter than
  the other, it is blank filled on the right.
  
  The value of C<is_sep> must be set to a true value, this is the
  distinguishing feature of a separator.
  
  =back
  
  =head2 Alignment
  
  The original documentation to L<Text::Aligner> contains all the details
  on alignment specification, but here is the rundown:
  
  The possible alignment specifications are I<left>, I<right>, I<center>,
  I<num> and I<point> (which are synonyms), and I<auto>.  The first
  three explain themselves.
  
  I<num> (and I<point>) align the decimal point in the data, which is
  assumed to the right if none is present.  Strings that aren't
  numbers are treated the same way, that is, they appear aligned
  with the integers unless they contain a ".".  Instead of the
  decimal point ".", you can also specify any other string in
  the form I<num(,)>, for instance.  The string in parentheses
  is aligned in the data.  The synonym I<point> for I<num> may be
  more appropriate in contexts that deal with arbitrary
  strings, as in I<point(=E<gt>)> (which might be used to align certain
  bits of Perl code).
  
  I<regex alignment> is a more sophisticated form of point alignment.
  If you specify a regular expression, as delivered by C<qr//>, the start
  of the match is used as the alignment point.  If the regex contains
  capturing parentheses, the last submatch counts.  [The usefulness of
  this feature is under consideration.]
  
  I<auto> alignment combines numeric alignment with left alignment.
  Data items that look like numbers, and those that don't, form two
  virtual columns and are aligned accordingly: C<num> for numbers and
  C<left> for other strings.  These columns are left-aligned with
  each other (i.e. the narrower one is blank-filled) to form the 
  final alignment.
  
  This way, a column that happens to have only numbers in the data gets
  I<num> alignment, a column with no numbers appears I<left>-aligned,
  and mixed data is presented in a reasonable way.
  
  =head2 Column Selection
  
  Besides creating tables from scratch, they can be created by
  selecting columns from an existing table.  Tables created this
  way contain the data from the columns they were built from.
  
  This is done by specifying the columns to select by their index
  (where negative indices count backward from the last column).
  The same column can be selected more than once and the sequence
  of columns can be arbitrarily changed.  Separators don't travel
  with columns, but can be specified between the columns at selection
  time.
  
  You can make the selection of one or more columns dependent on
  the data content of one of them.  If you specify some of the columns
  in angle brackets [...], the whole group is only included in the
  selection if the first column in the group contains any data that
  evaluates to boolean true.  That way you can de-select parts of a
  table if it contains no interesting data.  Any column separators
  given in brackets are selected or deselected along with the rest
  of it.
  
  =head1 PUBLIC METHODS
  
  =head2 Table Creation
  
  =over 4
  
  =item new()
  
      my $tb = Text::Table->new( $column, ... );
  
  creates a table with the columns specified.  A column can be proper column
  which contains and displays data, or a separator which tells how to fill
  the space between columns.  The format of the parameters is described under
  L<"Column Specification">. Specifying an invalid alignment for a column
  results in a warning if these are allowed.
  
  If no columns are specified, the number of columns is taken from the first
  line of data added to the table.  The effect is as if you had specified
  C<Text::Table-E<gt>new( ( '') x $n)>, where C<$n> is the number of
  columns.
  
  =item select()
  
      my $sub = $tb->select( $column, ...);
  
  creates a table from the listed columns of the table $tb, including
  the data.  Columns are specified as integer indices which refer to
  the data columns of $tb.  Columns can be repeated and specified in any
  order.  Negative indices count from the last column.  If an invalid
  index is specified, a warning is issued, if allowed.
  
  As with L<"new()">, separators can be interspersed among the column
  indices and will be used between the columns of the new table.
  
  If you enclose some of the arguments (column indices or separators) in
  angle brackets C<[...]> (technically, you specify them inside an
  arrayref), they form a group for conditional selection.  The group is
  only included in the resulting table if the first actual column inside
  the group contains any data that evaluate to a boolean true.  This way
  you can exclude groups of columns that wouldn't contribute anything
  interesting.  Note that separators are selected and de-selected with
  their group.  That way, more than one separator can appear between
  adjacent columns.  They don't add up, but only the rightmost separator
  is used.  A group that contains only separators is never selected.
  [Another feature whose usefulness is under consideration.]
  
  =back
  
  =head2 Status Information
  
  =over 4
  
  =item n_cols()
  
      $tb->n_cols
  
  returns the number of columns in the table.
  
  =item width()
  
      $tb->width
  
  returns the width (in characters) of the table.  All table lines have
  this length (not counting a final "\n" in the line), as well as the
  separator lines returned by $tb->rule() and $b->body_rule().
  The width of a table can potentially be influenced by any data item
  in it.
  
  =item height()
  
      $tb->height
  
  returns the total number of lines in a table, including title lines
  and body lines. For orthogonality, the synonym table_height() also
  exists.
  
  =item table_height()
  
  Same as C<< $table->height() >>.
  
  =item title_height()
  
      $tb->title_height
  
  returns the number of title lines in a table.
  
  =item body_height()
  
      $tb->body_height
  
  returns the number of lines in the table body.
  
  =item colrange()
  
      $tb->colrange( $i)
  
  returns the start position and width of the $i-th column (counting from 0)
  of the table.  If $i is negative, counts from the end of the table.  If $i
  is larger than the greatest column index, an imaginary column of width 0
  is assumed right of the table.
  
  =back
  
  =head2 Data Loading
  
  =over 4
  
  =item add()
  
      $tb->add( $col1, ..., $colN)
  
  adds a data line to the table, returns the table.
  
  C<$col1>, ..., C<$colN> are scalars that
  correspond to the table columns.  Undefined entries are converted to '',
  and extra data beyond the number of table columns is ignored.
  
  Data entries can be multi-line strings.  The partial strings all go into
  the same column.  The corresponding fields of other columns remain empty
  unless there is another multi-line entry in that column that fills the
  fieds.  Adding a line with multi-line entries is equivalent to adding
  multiple lines.
  
  Every call to C<add()> increases the body height of the table by the
  number of effective lines, one in the absence of multiline entries.
  
  =item load()
  
      $tb->load( $line, ...)
  
  loads the data lines given into the table, returns the table.
  
  Every argument to C<load()> represents a data line to be added to the
  table.  The line can be given as an array(ref) containing the data
  items, or as a string, which is split on whitespace to retrieve the
  data.  If an undefined argument is given, it is treated as an
  empty line.
  
  =item clear()
  
      $tb->clear;
  
  deletes all data from the table and resets it to the state after
  creation.  Returns the table.  The body height of a table is 0 after
  C<clear()>.
  
  =back
  
  =head2 Table Output
  
  The three methods C<table()>, C<title()>, and C<body()> are very similar.
  They access different parts of the printable output lines of a table with
  similar methods.  The details are described with the C<table()> method.
  
  =over 4
  
  =item table()
  
  The C<table()> method returns lines from the entire table, starting
  with the first title line and ending with the last body line.
  
  In array context, the lines are returned separately, in scalar context
  they are joined together in a single string.
  
      my @lines = $tb->table;
      my $line  = $tb->table( $line_number);
      my @lines = $tb->table( $line_number, $n);
  
  The first call returns all the lines in the table.  The second call
  returns one line given by $line_number.  The third call returns $n
  lines, starting with $line_number.  If $line_number is negative, it
  counts from the end of the array.  Unlike the C<select()> method,
  C<table()> (and its sister methods C<title()> and C<body()>) is
  protected against large negative line numbers, it truncates the
  range described by $line_number and $n to the existing lines.  If
  $n is 0 or negative, no lines are returned (an empty string in scalar
  context).
  
  =item stringify()
  
  Returns a string representation of the table. This method is called for
  stringification by overload.
  
      my @table_strings = map { $_->stringify() } @tables;
  
  =item title()
  
  Returns lines from the title area of a table, where the column titles
  are rendered.  Parameters and response to context are as with C<table()>,
  but no lines are returned from outside the title area.
  
  =item body()
  
  Returns lines from the body area of a table, that is the part where
  the data content is rendered, so that $tb->body( 0) is the first data
  line.  Parameters and response to context are as with C<table()>.
  
  =item rule()
  
      $tb->rule;
      $tb->rule( $char);
      $tb->rule( $char, $char1);
      $tb->rule( sub { my ($index, $len) = @_; }, 
                 sub { my ($index, $len) = @_; },
      );
  
  Returns a rule for the table.
  
  A rule is a line of table width that can be used between table lines
  to provide visual horizontal divisions, much like column separators
  provide vertical visual divisions.  In its basic form (returned by the
  first call) it looks like a table line with no data, hence a blank
  line except for the non-blank parts of any column-separators.  If
  one character is specified (the second call), it replaces the blanks
  in the first form, but non-blank column separators are retained.  If
  a second character is specified, it replaces the non-blank parts of
  the separators.  So specifying the same character twice gives a solid
  line of table width.  Another useful combo is C<$tb-E<lt>rule( '-', '+')>,
  together with separators that contain a single nonblank "|", for a
  popular representation of line crossings.
  
  C<rule()> uses the column separators for the title section if there
  is a difference.
  
  If callbacks are specified instead of the characters, then they receive the
  index of the section of the rule they need to render and its desired length in
  characters, and should return the string to put there. The indexes given
  are 0 based (where 0 is either the left column separator or the leftmost
  cell) and the strings will be trimmed or extended in the replacement.
  
  =item body_rule()
  
  C<body_rule()> works like <rule()>, except the rule is generated using
  the column separators for the table body.
  
  =back
  
  =head2 Warning Control
  
  =over 4
  
  =item warnings()
  
      Text::Table->warnings();
      Text::Table->warnings( 'on');
      Text::Table->warnings( 'off'):
      Text::Table->warnings( 'fatal'):
  
  The C<warnings()> method is used to control the appearance of warning
  messages while tables are manipulated.  When Text::Table starts, warnings
  are disabled.  The default action of C<warnings()> is to turn warnings
  on.  The other possible arguments are self-explanatory.  C<warnings()>
  can also be called as an object method (C<$tb-E<gt>warnings( ...)>).
  
  =back
  
  =head1 VERSION
      
  This document pertains to Text::Table version 1.121
  
  =head1 BUGS
  
  =over 4
  
  =item o
  
  I<auto> alignment doesn't support alternative characters for the decimal
  point.  This is actually a bug in the underlying Text::Aligner by the
  same author.
  
  =back
  
  =head1 AUTHOR
  
  =head2 MAINTAINER
  
  Shlomi Fish, L<http://www.shlomifish.org/> - CPAN ID: "SHLOMIF".
  
  =head2 ORIGINAL AUTHOR
  
      Anno Siegel
      CPAN ID: ANNO 
      siegel@zrz.tu-berlin.de
      http://www.tu-berlin.de/~siegel
  
  =head1 COPYRIGHT
  
  Copyright (c) 2002 Anno Siegel. All rights reserved.
  This program is free software; you can redistribute
  it and/or modify it under the terms of the ISC license.
  
  (This program had been licensed under the same terms as Perl itself up to
  version 1.118 released on 2011, and was relicensed by permission of its
  originator).
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =head1 SEE ALSO
  
  L<Text::Aligner>, L<perl(1)> .
  
  =cut
  
  1;
TEXT_TABLE

s/^  //mg for values %fatpacked;

unshift @INC, sub {
  if (my $fat = $fatpacked{$_[1]}) {
    open my $fh, '<', \$fat
      or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
    return $fh;
  }
  return
};

} # END OF FATPACK CODE

use strict;
use App::llenv;

unless (caller) {
    my $app = App::llenv->new;
    $app->init;
    $app->parse_options(@ARGV);
    $app->run or exit(1);
}

__END__
