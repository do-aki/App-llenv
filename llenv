#!/usr/bin/env perl
# DO NOT EDIT -- this is an auto generated file
# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"App/llenv.pm"} = <<'APP_LLENV';
  package App::llenv;
  use 5.008_001;
  use strict;
  use warnings;
  use Getopt::Compact::WithCmd;
  use File::Spec::Functions qw( catfile catdir );
  use File::Path qw( mkpath );
  use Cwd;
  
  our $VERSION = '0.01';
  
  sub new {
      my $class = shift;
      my $self = {};
      bless $self, $class;
      return $self;
  }
  
  sub init {
      my $self = shift;
  
      if (! -d $ENV{LLENV_ROOT}) {
          mkpath $ENV{LLENV_ROOT} or die("failed to create $ENV{LLENV_ROOT}: $!");
      }
  
      if (! -f $self->abs_path('llenv_config.pl')) {
          open my $fh, '>', $self->abs_path('llenv_config.pl');
          print {$fh} <<"EOF";
  +{
      common => {
          app_dir => 'apps',
          bin_dir => 'bin',
      },
      perl => {
          env_bundle_lib   => 'PERL5OPT',
          env_app_lib      => 'PERL5OPT',
          tmpl_bundle_lib  => 'local/lib/perl5',
          tmpl_bundle_path => 'local/bin',
          tmpl_app_lib     => 'lib',
          tmpl_app_path    => 'bin',
      },
      ruby => {
          env_bundle_lib   => 'GEM_PATH',
          env_app_lib      => 'RUBYLIB',
          tmpl_bundle_lib  => 'vendor/bundle/ruby/1.9.1',
          tmpl_bundle_path => 'vendor/bundle/ruby/1.9.1/bin',
          tmpl_app_lib     => 'lib',
          tmpl_app_path    => 'bin',
      },
      python => {
          env_bundle_lib   => 'PYTHONPATH',
          env_app_lib      => 'PYTHONPATH',
          tmpl_bundle_lib  => 'lib/python2.7/site-packages',
          tmpl_bundle_path => 'bin',
          tmpl_app_lib     => 'lib',
          tmpl_app_path    => 'bin',
      },
      node => {
          env_bundle_lib   => 'NODE_PATH',
          env_app_lib      => 'NODE_PATH',
          tmpl_bundle_lib  => 'node_modules',
          tmpl_bundle_path => 'node_modules/.bin',
          tmpl_app_lib     => 'lib',
          tmpl_app_path    => 'bin',
      },
  };
  EOF
          close $fh;
      }
      $self->{'conf'} = _get_config_pl(catfile($ENV{LLENV_ROOT}, 'llenv_config.pl'));
  
      my $app_dir = $self->abs_path($self->{'conf'}->{'common'}->{'app_dir'});
      my $bin_dir = $self->abs_path($self->{'conf'}->{'common'}->{'bin_dir'});
      for my $path ($app_dir, $bin_dir) {
          if (! -d $path) {
              mkpath $path or die("failed to create $path: $!");
          }
      }
  }
  
  sub parse_options {
      my $self = shift;
      
      my $go = Getopt::Compact::WithCmd->new(
          name          => 'llenv',
          version       => $VERSION,
          command_struct => {
              init => {
                  desc        => 'init llenv',
              },
              setup => {
                  options     => [
                      [ [qw/l ll/], 'LL', '=s', undef, { required => 1 } ],
                      [ [qw/v version/], 'LL version', '=s' ],
                  ],
                  desc        => 'setup llenv app dir',
                  args        => 'APP_NAME',
              },
              exec => {
                  desc        => 'exec cwd script',
                  args        => 'SCRIPT_NAME[ -- SCRIPTOPTIONS]',
              },
              install => {
                  desc        => 'install cwd script to bin dir',
                  args        => 'SCRIPT_NAME',
              },
          },
      );
  
      $self->{'go'} = $go;
      $self->{'command'} = $go->command || $go->show_usage;
      $self->{'opts'} = $go->opts;
  }
  
  sub run {
      my($self) = @_;
      $self->can('command_' . $self->{'command'})->($self, @ARGV);
  }
  
  sub command_init {
      my ($self, @args) = @_;
      print <<EOF;
  llenv init
  
  export LLENV_ROOT=$ENV{LLENV_ROOT}
  export LLENV_OSTYPE=`\$LLENV_ROOT/bin/ostype`
  export PATH=\$LLENV_ROOT/bin:\$PATH
  
  EOF
  }
  
  sub command_install {
      my ($self, @args) = @_;
      $self->{'go'}->show_usage unless(scalar @args == 1);
      my $script = shift @args;
      my ($ll_path, $script_file, $env) = $self->get_script_env($script);
      $self->set_env($env);
  
      my $bin_dir = $self->{'conf'}->{'common'}->{'bin_dir'};
      if (! -d $self->abs_path($bin_dir)) {
          mkpath $self->abs_path($bin_dir)
              or die "failed to create $bin_dir: $!";
      }
  
      my $abs_script = $self->abs_path($bin_dir, $script);
      my $export_env = join "\n", map { "export $_=\"$env->{$_}\$$_\"" } keys %$env;
      open my $fh, '>', $abs_script;
      print {$fh} <<"EOF";
  #!/bin/sh
  $export_env
  exec $ll_path $script_file "\$@"
  EOF
      close $fh;
      system("chmod +x $abs_script");
  }
  
  sub command_exec {
      my ($self, @args) = @_;
      $self->{'go'}->show_usage if(scalar @args < 1);
      my $script = shift @args;
  
      my ($ll_path, $script_file, $env) = $self->get_script_env($script);
      $self->set_env($env);
      system("$ll_path $script_file @args");
  }
  
  sub set_env {
      my ($self, $env) = @_;
      my $LLENV_ROOT = $ENV{LLENV_ROOT};
      for (keys %$env) {
          $ENV{$_} = '' unless defined $ENV{$_};
          my $str = eval "qq{$env->{$_}}";
          $ENV{$_} = $str.$ENV{$_};
      }
  }
  
  sub get_script_env {
      my ($self, $script) = @_;
  
      my $llenv_file = catdir(getcwd, '.llenv.pl');
      my $app_conf = _get_config_pl($llenv_file);
      my $ll = (keys %{$app_conf})[0];
      my $conf = $app_conf->{$ll};
  
      my $ll_path = $conf->{'ll_path'};
      my $local_path = $self->get_local_path($conf);
      my $script_file = $self->get_script_path($conf, $script);
      my ($env_bundle_lib, $bundle_lib) = $self->get_bundle_lib($ll, $conf->{'bundle_lib'});
      my ($env_app_lib, $app_lib) = $self->get_app_lib($ll, $conf->{'app_lib'});
      my $env = {
          'PATH' => $local_path,
      };
      $env->{$env_bundle_lib} .= $bundle_lib;
      $env->{$env_app_lib} .= $app_lib;
  
      return ($ll_path, $script_file, $env);
  }
  
  sub get_script_path {
      my ($self, $conf, $script) = @_;
      for (qw/app_path bundle_path/) {
          next unless(defined $conf->{$_});
          my $full_path = $self->abs_path($conf->{$_}, $script);
          return catfile('$LLENV_ROOT', $conf->{$_}, $script) if(-f $full_path);
      }
      die "not found $script";
  }
  
  sub get_local_path {
      my ($self, $conf) = @_;
      my $path = '';
      for (qw/bundle_path app_path/) {
          next unless(defined $conf->{$_});
          my $_path = catdir('$LLENV_ROOT', $conf->{$_});
          $path = "$_path:$path";
      }
      return $path;
  }
  
  sub get_bundle_lib {
      my ($self, $ll, $lib) = @_;
      my $env_bundle_lib = $self->{'conf'}->{$ll}->{'env_bundle_lib'};
      $lib = catdir('$LLENV_ROOT', $lib);
      if ($ll eq 'perl') {
          $lib = "-Mlib=$lib ";
      } else {
          $lib = "$lib:";
      }
      return ($env_bundle_lib, $lib);
  }
  
  sub get_app_lib {
      my ($self, $ll, $lib) = @_;
      my $env_app_lib = $self->{'conf'}->{$ll}->{'env_app_lib'};
      $lib = catdir('$LLENV_ROOT', $lib);
      if ($ll eq 'perl') {
          $lib = "-Mlib=$lib ";
      } else {
          $lib = "$lib:";
      }
      return ($env_app_lib, $lib);
  }
  
  sub command_setup {
      my ($self, @args) = @_;
      $self->{'go'}->show_usage unless(scalar @args == 1);
      my $app_name = $args[0];
      my $opts = $self->{'opts'};
      my $conf = $self->{'conf'}->{$opts->{'ll'}}
          or die("not found $opts->{'ll'} conf");
  
      my $ll_path = defined $opts->{'version'}
          ? `llinstall path $opts->{'ll'} $opts->{'version'}` : "/usr/bin/env $opts->{'ll'}";
      chomp $ll_path;
  
      my $app_dir = catdir($self->{'conf'}->{'common'}->{'app_dir'}, $app_name);
      my $app_bundle_lib = catdir($app_dir, $conf->{'tmpl_bundle_lib'});
      my $app_bundle_path = catdir($app_dir, $conf->{'tmpl_bundle_path'});
      my $app_lib = catdir($app_dir, $conf->{'tmpl_app_lib'});
      my $app_path = catdir($app_dir, $conf->{'tmpl_app_path'});
  
      if (! -d $self->abs_path($app_dir)) {
          mkpath $self->abs_path($app_dir)
              or die("failed to create $app_dir: $!");
      }
  
      open my $fh, '>', $self->abs_path($app_dir, '.llenv.pl');
      print {$fh} <<"EOF";
  +{
      $opts->{'ll'} => {
          ll_path     => '$ll_path',
          bundle_lib  => '$app_bundle_lib',
          bundle_path => '$app_bundle_path',
          app_lib     => '$app_lib',
          app_path    => '$app_path',
      },
  }
  EOF
      close $fh;
  }
  
  sub abs_path {
      my ($self, @path) = @_;
      return catdir($ENV{LLENV_ROOT}, @path);
  }
  
  sub _get_config_pl {
      my ($fname) = @_;
      my $config = do $fname;
      die("$fname: $@") if $@;
      die("$fname: $!") unless defined $config;
      unless ( ref($config) eq 'HASH' ) {
          die("$fname does not return HashRef.");
      }
      return $config;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  App::llenv - Perl extention to do something
  
  =head1 VERSION
  
  This document describes App::llenv version 0.01.
  
  =head1 SYNOPSIS
  
      use App::llenv;
  
  =head1 DESCRIPTION
  
  # TODO
  
  =head1 INTERFACE
  
  =head2 Functions
  
  =head3 C<< hello() >>
  
  # TODO
  
  =head1 DEPENDENCIES
  
  Perl 5.8.1 or later.
  
  =head1 BUGS
  
  All complex software has bugs lurking in it, and this module is no
  exception. If you find a bug please either email me, or add the bug
  to cpan-RT.
  
  =head1 SEE ALSO
  
  L<perl>
  
  =head1 AUTHOR
  
  riywo E<lt>riywo.jp@gmail.comE<gt>
  
  =head1 LICENSE AND COPYRIGHT
  
  Copyright (c) 2012, riywo. All rights reserved.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
APP_LLENV

$fatpacked{"App/llinstall.pm"} = <<'APP_LLINSTALL';
  package App::llinstall;
  use 5.008_001;
  use strict;
  use warnings;
  use Getopt::Compact::WithCmd;
  use File::Spec::Functions qw( catfile catdir );
  use File::Path qw( mkpath );
  use Cwd;
  
  our $VERSION = '0.01';
  
  sub new {
      my $class = shift;
      die "not defined LLENV_ROOT" unless(defined $ENV{LLENV_ROOT});
      die "not defined LLENV_OSTYPE" unless(defined $ENV{LLENV_OSTYPE});
      my $self = {};
      bless $self, $class;
      return $self;
  }
  
  sub init {
      my $self = shift;
  
      if (! -d $ENV{LLENV_ROOT}) {
          mkpath $ENV{LLENV_ROOT} or die("failed to create $ENV{LLENV_ROOT}: $!");
      }
  
      if (! -f $self->abs_path('llinstall_config.pl')) {
          open my $fh, '>', $self->abs_path('llinstall_config.pl');
          print {$fh} <<"EOF";
  +{
      common => {
      },
      perl => {
          env     => 'export PERLBREW_ROOT=\$LLENV_ROOT/lls/\$LLENV_OSTYPE/perl; export PERLBREW_HOME=\$LLENV_ROOT/lls/\$LLENV_OSTYPE/perl;',
          init    => 'curl -kL http://install.perlbrew.pl | bash',
          install => 'source \$PERLBREW_ROOT/etc/bashrc && perlbrew install --notest',
          ll_dir  => '\$LLENV_ROOT/lls/\$LLENV_OSTYPE/perl/perls',
      },
      ruby => {
          env     => 'export RBENV_ROOT=\$LLENV_ROOT/lls/\$LLENV_OSTYPE/ruby; export PATH=\$RBENV_ROOT/bin:\$PATH;',
          init    => 'GIT_SSL_NO_VERIFY=true git clone https://github.com/sstephenson/rbenv.git \$RBENV_ROOT && GIT_SSL_NO_VERIFY=true git clone https://github.com/sstephenson/ruby-build.git \$RBENV_ROOT/ruby-build && (cd \$RBENV_ROOT/ruby-build && PREFIX=\$RBENV_ROOT ./install.sh)',
          install => 'eval "\$(rbenv init -)" && rbenv install',
          ll_dir  => '\$LLENV_ROOT/lls/\$LLENV_OSTYPE/ruby/versions',
      },
      python => {
          env     => 'export PYTHONBREW_ROOT=\$LLENV_ROOT/lls/\$LLENV_OSTYPE/python; export PYTHONBREW_HOME=\$LLENV_ROOT/lls/\$LLENV_OSTYPE/python;',
          init    => 'curl -kL http://xrl.us/pythonbrewinstall | bash',
          install => 'source \$PYTHONBREW_ROOT/etc/bashrc && pythonbrew install --verbose --no-test',
          ll_dir  => '\$LLENV_ROOT/lls/\$LLENV_OSTYPE/python/pythons',
      },
      node => {
          env     => 'export NVM_DIR=\$LLENV_ROOT/lls/\$LLENV_OSTYPE/node;',
          init    => 'GIT_SSL_NO_VERIFY=true git clone https://github.com/creationix/nvm.git \$NVM_DIR',
          install => 'source \$NVM_DIR/nvm.sh; nvm install',
          ll_dir  => '\$LLENV_ROOT/lls/\$LLENV_OSTYPE/node',
      },
  };
  EOF
          close $fh;
      }
      $self->{'conf'} = _get_config_pl(catfile($ENV{LLENV_ROOT}, 'llinstall_config.pl'));
  }
  
  sub parse_options {
      my $self = shift;
      
      my $go = Getopt::Compact::WithCmd->new(
          name          => 'llinstall',
          version       => $VERSION,
          command_struct => {
              init => {
                  desc        => 'init llinstall',
                  args        => 'LL',
              },
              install => {
                  desc        => 'install LL',
                  args        => 'LL VERSION',
              },
              list => {
                  desc        => 'list LL',
                  args        => 'LL',
              },
              path => {
                  desc        => 'LL path',
                  args        => 'LL VERSION',
              },
          },
      );
  
      $self->{'go'} = $go;
      $self->{'command'} = $go->command || $go->show_usage;
      $self->{'opts'} = $go->opts;
  }
  
  sub run {
      my($self) = @_;
      $self->can('command_' . $self->{'command'})->($self, @ARGV);
  }
  
  sub command_init {
      my ($self, @args) = @_;
      $self->{'go'}->show_usage unless(scalar @args == 1);
      my ($ll) = @args;
      die "not found $ll in llinstall_config.pl" unless(defined $self->{conf}->{$ll});
      my $conf = $self->{'conf'}->{$ll};
  
      system("$conf->{'env'} $conf->{'init'}");
  }
  
  sub command_install {
      my ($self, @args) = @_;
      $self->{'go'}->show_usage unless(scalar @args == 2);
      my ($ll, $version) = @args;
      die "not found $ll in llinstall_config.pl" unless(defined $self->{conf}->{$ll});
      my $conf = $self->{'conf'}->{$ll};
  
      system("$conf->{'env'} $conf->{'install'} $version");
  }
  
  sub command_list {
      my ($self, @args) = @_;
      $self->{'go'}->show_usage unless(scalar @args == 1);
      my ($ll) = @args;
      die "not found $ll in llinstall_config.pl" unless(defined $self->{conf}->{$ll});
      my $conf = $self->{'conf'}->{$ll};
  
      my $LLENV_ROOT = $ENV{LLENV_ROOT};
      my $LLENV_OSTYPE = $ENV{LLENV_OSTYPE};
      my $ll_dir = eval "qq{$conf->{'ll_dir'}}";
  
      opendir my $dh, $ll_dir or die "cannot opendir $ll_dir";
      for my $dir (sort readdir $dh) {
          next if($dir eq '.' or $dir eq '..');
          next unless(-d catfile($ll_dir, $dir));
          print "$dir\n";
      }
  }
  
  sub command_path {
      my ($self, @args) = @_;
      $self->{'go'}->show_usage unless(scalar @args == 2);
      my ($ll, $version) = @args;
      die "not found $ll in llinstall_config.pl" unless(defined $self->{conf}->{$ll});
      my $conf = $self->{'conf'}->{$ll};
  
      my $path = catfile($conf->{'ll_dir'}, $version, 'bin', $ll);
      my $LLENV_ROOT = $ENV{LLENV_ROOT};
      my $LLENV_OSTYPE = $ENV{LLENV_OSTYPE};
      my $abs_path = eval "qq{$path}";
      die "not found $abs_path" unless(-f $abs_path);
      print $path."\n";
  }
  
  
  
  
  sub abs_path {
      my ($self, @path) = @_;
      return catdir($ENV{LLENV_ROOT}, @path);
  }
  
  sub _get_config_pl {
      my ($fname) = @_;
      my $config = do $fname;
      die("$fname: $@") if $@;
      die("$fname: $!") unless defined $config;
      unless ( ref($config) eq 'HASH' ) {
          die("$fname does not return HashRef.");
      }
      return $config;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  App::llenv - Perl extention to do something
  
  =head1 VERSION
  
  This document describes App::llenv version 0.01.
  
  =head1 SYNOPSIS
  
      use App::llenv;
  
  =head1 DESCRIPTION
  
  # TODO
  
  =head1 INTERFACE
  
  =head2 Functions
  
  =head3 C<< hello() >>
  
  # TODO
  
  =head1 DEPENDENCIES
  
  Perl 5.8.1 or later.
  
  =head1 BUGS
  
  All complex software has bugs lurking in it, and this module is no
  exception. If you find a bug please either email me, or add the bug
  to cpan-RT.
  
  =head1 SEE ALSO
  
  L<perl>
  
  =head1 AUTHOR
  
  riywo E<lt>riywo.jp@gmail.comE<gt>
  
  =head1 LICENSE AND COPYRIGHT
  
  Copyright (c) 2012, riywo. All rights reserved.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
APP_LLINSTALL

$fatpacked{"Getopt/Compact/WithCmd.pm"} = <<'GETOPT_COMPACT_WITHCMD';
  package Getopt::Compact::WithCmd;
  
  use strict;
  use warnings;
  use 5.008_001;
  use Data::Dumper ();
  use List::Util qw(max);
  use Getopt::Long qw(GetOptionsFromArray);
  use Carp ();
  use constant DEFAULT_CONFIG => (no_auto_abbrev => 1, bundling => 1);
  
  our $VERSION = '0.19';
  
  my $TYPE_MAP = {
      'Bool'   => '!',
      'Incr'   => '+',
      'Str'    => '=s',
      'Int'    => '=i',
      'Num'    => '=f',
      'ExNum'  => '=o',
  };
  
  my $TYPE_GEN = {};
  
  sub new {
      my ($class, %args) = @_;
      my $self = bless {
          cmd         => $args{cmd} || do { require File::Basename; File::Basename::basename($0) },
          name        => $args{name},
          version     => $args{version} || $::VERSION,
          modes       => $args{modes},
          opt         => {},
          usage       => exists $args{usage} && !$args{usage} ? 0 : 1,
          args        => $args{args} || '',
          _argv       => \@ARGV,
          struct      => [],
          summary     => {},
          requires    => {},
          ret         => 0,
          error       => undef,
          other_usage => undef,
          commands    => [],
          _struct     => $args{command_struct} || {},
      }, $class;
  
      my %config = (DEFAULT_CONFIG, %{$args{configure} || {}});
      my @gconf = grep $config{$_}, keys %config;
      Getopt::Long::Configure(@gconf) if @gconf;
  
      $self->_init_summary($args{command_struct});
  
      $self->_init_struct($args{global_struct} || []);
      my $opthash = $self->_parse_struct || return $self;
      if ($args{command_struct}) {
          if (my @gopts = $self->_parse_argv) {
              $self->{ret} = $self->_parse_option(\@gopts, $opthash);
              return $self unless $self->{ret};
              return $self if $self->_want_help;
          }
          $self->_check_requires;
      }
      else {
          $self->{ret} = $self->_parse_option(\@ARGV, $opthash);
          return $self unless $self->{ret};
          return $self if $self->_want_help;
          $self->_check_requires;
          return $self;
      }
  
      $self->_parse_command_struct($args{command_struct});
      return $self;
  }
  
  sub new_from_array {
      my ($class, $args, %options) = @_;
      unless (ref $args eq 'ARRAY') {
          Carp::croak("Usage: $class->new_from_array(\\\@args, %options)");
      }
      local *ARGV = $args;
      return $class->new(%options);
  }
  
  sub new_from_string {
      my ($class, $str, %options) = @_;
      unless (defined $str) {
          Carp::croak("Usage: $class->new_from_string(\$str, %options)");
      }
      require Text::ParseWords;
      my $args = [Text::ParseWords::shellwords($str)];
      local *ARGV = $args;
      return $class->new(%options);
  }
  
  sub args       { $_[0]->{_argv}     }
  sub error      { $_[0]->{error}||'' }
  sub command    { $_[0]->{command}   }
  sub commands   { $_[0]->{commands}  }
  sub status     { $_[0]->{ret}       }
  sub is_success { $_[0]->{ret}       }
  sub pod2usage  { Carp::carp('Not implemented') }
  
  sub opts {
      my($self) = @_;
      my $opt = $self->{opt};
      if ($self->{usage} && ($opt->{help} || $self->status == 0)) {
          # display usage message & exit
          print $self->usage;
          exit !$self->status;
      }
      return $opt;
  }
  
  sub usage {
      my($self, @targets) = @_;
      my $usage = '';
      my(@help, @commands);
  
      if ((defined $self->command && $self->command eq 'help') || @targets) {
          delete $self->{command};
          @targets = @{$self->{_argv}} unless @targets;
          for (my $i = 0; $i < @targets; $i++) {
              my $target = $targets[$i];
              last unless defined $target;
              unless (ref $self->{_struct}{$target} eq 'HASH') {
                  $self->{error} = "Unknown command: $target";
                  last;
              }
              else {
                  $self->{command} = $target;
                  push @{$self->{commands}}, $target;
                  $self->_init_struct($self->{_struct}{$target}{options});
                  $self->_extends_usage($self->{_struct}{$target});
  
                  if (ref $self->{_struct}{$target}{command_struct} eq 'HASH') {
                      $self->{_struct} = $self->{_struct}{$target}{command_struct};
                  }
                  else {
                      $self->{summary} = {};
                  }
              }
          }
      }
  
      my($name, $version, $cmd, $struct, $args, $summary, $error, $other_usage) = map
          $self->{$_} || '', qw/name version cmd struct args summary error other_usage/;
  
      $usage .= "$error\n" if $error;
  
      if ($name) {
          $usage .= $name;
          $usage .= " v$version" if $version;
          $usage .= "\n";
      }
  
      if ($self->command && $self->command ne 'help') {
          my $sub_command = join q{ }, @{$self->commands} ? @{$self->commands} : $self->command;
          $usage .= "usage: $cmd $sub_command [options]";
      }
      else {
          $usage .= "usage: $cmd [options]";
          $usage .= ' COMMAND' if keys %$summary;
      }
      $usage .= ($args ? " $args" : '') . "\n\n";
  
      for my $o (@$struct) {
          my ($name_spec, $desc, $arg_spec, $dist, $opts) = @$o;
          $desc = '' unless defined $desc;
          my @onames = $self->_option_names($name_spec);
          my $optname = join
              (', ', map { (length($_) > 1 ? '--' : '-').$_ } @onames);
          $optname = '    '.$optname unless length($onames[0]) == 1;
          my $info = do {
              local $Data::Dumper::Indent = 0;
              local $Data::Dumper::Terse  = 1;
              my $info = [];
              push @$info, $self->_opt_spec2name($arg_spec) || $arg_spec || '';
              push @$info, $opts->{required}        ? "(required)" : '';
              push @$info, defined $opts->{default} ? "(default: ".Data::Dumper::Dumper($opts->{default}).")" : '';
              $info;
          };
          push @help, [ $optname, $info, ucfirst($desc) ];
      }
  
      if (@help) {
          require Text::Table;
          my $sep = \'   ';
          $usage .= "options:\n";
          $usage .= Text::Table->new($sep, '', $sep, '', $sep, '')->load($self->_format_info(@help))->stringify."\n";
      }
  
      if (defined $other_usage && length $other_usage > 0) {
          $other_usage =~ s/\n$//ms;
          $usage .= "$other_usage\n\n";
      }
  
      if (!$self->command || $self->{has_sub_command}) {
          for my $command (sort keys %$summary) {
              push @commands, [ $command, ucfirst $summary->{$command} ];
          }
  
          if (@commands) {
              require Text::Table;
              my $sep = \'   ';
              $usage .= "Implemented commands are:\n";
              $usage .= Text::Table->new($sep, '', $sep, '')->load(@commands)->stringify."\n";
              my $help_command = "$cmd help COMMAND";
              if (@{$self->commands}) {
                  my $sub_commands = join q{ }, @{$self->commands};
                  $help_command = "$cmd $sub_commands COMMAND --help";
              }
              $usage .= "See '$help_command' for more information on a specific command.\n\n";
          }
      }
  
      return $usage;
  }
  
  sub show_usage {
      my $self = shift;
      print $self->usage(@_);
      exit !$self->status;
  }
  
  sub _opt_spec2name {
      my ($self, $spec) = @_;
      my $name = '';
      return $name unless defined $spec;
      my ($type, $dest) = $spec =~ /^[=:]?([!+isof])([@%])?/;
      if ($type) {
          $name =
              $type eq '!' ? 'Bool'  :
              $type eq '+' ? 'Incr'  :
              $type eq 's' ? 'Str'   :
              $type eq 'i' ? 'Int'   :
              $type eq 'f' ? 'Num'   :
              $type eq 'o' ? 'ExNum' : '';
      }
      if ($dest) {
          $name = $dest eq '@' ? "Array[$name]" : $dest eq '%' ? "Hash[$name]" : $name;
      }
      return $name;
  }
  
  sub _format_info {
      my ($self, @help) = @_;
  
      my $type_max     = 0;
      my $required_max = 0;
      my $default_max  = 0;
      for my $row (@help) {
          my ($type, $required, $default) = @{$row->[1]};
          $type_max     = max $type_max, length($type);
          $required_max = max $required_max, length($required);
          $default_max  = max $default_max, length($default);
      }
  
      for my $row (@help) {
          my ($type, $required, $default) = @{$row->[1]};
          my $parts = [];
          for my $stuff ([$type_max, $type], [$required_max, $required], [$default_max, $default]) {
              push @$parts, sprintf '%-*s', @$stuff if $stuff->[0] > 0;
          }
          $row->[1] = join ' ', @$parts;
      }
  
      return @help;
  }
  
  sub _parse_command_struct {
      my ($self, $command_struct) = @_;
      $command_struct ||= {};
  
      my $command_map = { map { $_ => 1 } keys %$command_struct };
      my $command = shift @ARGV;
      unless ($command) {
          $self->{ret} = $self->_check_requires;
          return $self;
      }
  
      unless ($command_map->{help}) {
          $command_map->{help} = 1;
          $command_struct->{help} = {
              args => '[COMMAND]',
              desc => 'show help message',
          };
      }
  
      unless (exists $command_map->{$command}) {
          $self->{error} = "Unknown command: $command";
          $self->{ret} = 0;
          return $self;
      }
  
      $self->{command} ||= $command;
  
      if ($command eq 'help') {
          $self->{ret} = 0;
          delete $self->{error};
          if (defined $ARGV[0] && exists $command_struct->{$ARGV[0]}) {
              my $nested_struct = $command_struct->{$ARGV[0]}{command_struct};
              $self->_init_nested_struct($nested_struct) if $nested_struct;
          }
          return $self;
      }
  
      push @{$self->{commands} ||= []}, $command;
      $self->_init_struct($command_struct->{$command}{options});
      $self->_extends_usage($command_struct->{$command});
      my $opthash = $self->_parse_struct || return $self;
  
      if (my $nested_struct = $command_struct->{$command}{command_struct}) {
          $self->_init_nested_struct($nested_struct);
  
          my @opts = $self->_parse_argv;
          $self->{ret} = $self->_parse_option(\@opts, $opthash);
          $self->_check_requires;
          if ($self->_want_help) {
              delete $self->{error};
              $self->{ret} = 0;
          }
          return $self unless $self->{ret};
          $self->_parse_command_struct($nested_struct);
      }
      else {
          $self->{ret} = $self->_parse_option(\@ARGV, $opthash);
          $self->_check_requires;
          $self->{has_sub_command} = 0;
          if ($self->_want_help) {
              delete $self->{error};
              $self->{ret} = 0;
          }
      }
  
      return $self;
  }
  
  sub _want_help {
      exists $_[0]->{opt}{help} && $_[0]->{opt}{help} ? 1 : 0;
  }
  
  sub _init_nested_struct {
      my ($self, $nested_struct) = @_;
      $self->{summary} = {}; # reset
      $self->_init_summary($nested_struct);
      $self->{has_sub_command} = 1;
  }
  
  sub _parse_option {
      my ($self, $argv, $opthash) = @_;
      local $SIG{__WARN__} = sub {
          $self->{error} = join '', @_;
          chomp $self->{error};
      };
      my $ret = GetOptionsFromArray($argv, %$opthash) ? 1 : 0;
  
      $self->{parsed_opthash} = $opthash;
  
      return $ret;
  }
  
  sub _parse_argv {
      my @opts;
      while (@ARGV) {
          last unless $ARGV[0] =~ /^-/;
          push @opts, shift @ARGV;
      }
      return @opts;
  }
  
  sub _parse_struct {
      my ($self) = @_;
      my $struct = $self->{struct};
  
      my $opthash = {};
      my $default_opthash = {};
      my $default_args = [];
      for my $s (@$struct) {
          my($m, $descr, $spec, $ref, $opts) = @$s;
          my @onames = $self->_option_names($m);
          my($longname) = grep length($_) > 1, @onames;
          my ($type, $cb) = $self->_compile_spec($spec);
          my $o = join('|', @onames).($type||'');
          my $dest = $longname ? $longname : $onames[0];
          $opts ||= {};
          my $destination;
          if (ref $cb eq 'CODE') {
              my $t =
                  substr($type, -1, 1) eq '@' ? 'Array' :
                  substr($type, -1, 1) eq '%' ? 'Hash'  : '';
              if (ref $ref eq 'CODE') {
                  $destination = sub { $ref->($_[0], $cb->($_[1])) };
              }
              elsif (ref $ref) {
                  if (ref $ref eq 'SCALAR' || ref $ref eq 'REF') {
                      $$ref = $t eq 'Array' ? [] : $t eq 'Hash' ? {} : undef;
                  }
                  elsif (ref $ref eq 'ARRAY') {
                      @$ref = ();
                  }
                  elsif (ref $ref eq 'HASH') {
                      %$ref = ();
                  }
                  $destination = sub {
                      if ($t eq 'Array') {
                          if (ref $ref eq 'SCALAR' || ref $ref eq 'REF') {
                              push @{$$ref}, scalar $cb->($_[1]);
                          }
                          elsif (ref $ref eq 'ARRAY') {
                              push @$ref, scalar $cb->($_[1]);
                          }
                          elsif (ref $ref eq 'HASH') {
                              my @kv = split '=', $_[1], 2;
                              die qq(Option $_[0], key "$_[1]", requires a value\n)
                                  unless @kv == 2;
                              $ref->{$kv[0]} = scalar $cb->($kv[1]);
                          }
                      }
                      elsif ($t eq 'Hash') {
                          if (ref $ref eq 'SCALAR' || ref $ref eq 'REF') {
                              $$ref->{$_[1]} = scalar $cb->($_[2]);
                          }
                          elsif (ref $ref eq 'ARRAY') {
                              # XXX but Getopt::Long is $ret = join '=', $_[1], $_[2];
                              push @$ref, $_[1], scalar $cb->($_[2]);
                          }
                          elsif (ref $ref eq 'HASH') {
                              $ref->{$_[1]} = scalar $cb->($_[2]);
                          }
                      }
                      else {
                          if (ref $ref eq 'SCALAR' || ref $ref eq 'REF') {
                              $$ref = $cb->($_[1]);
                          }
                          elsif (ref $ref eq 'ARRAY') {
                              @$ref = (scalar $cb->($_[1]));
                          }
                          elsif (ref $ref eq 'HASH') {
                              my @kv = split '=', $_[1], 2;
                              die qq(Option $_[0], key "$_[1]", requires a value\n)
                                  unless @kv == 2;
                              %$ref = ($kv[0] => scalar $cb->($kv[1]));
                          }
                      }
                  };
              }
              else {
                  $destination = sub {
                      if ($t eq 'Array') {
                          $self->{opt}{$dest} ||= [];
                          push @{$self->{opt}{$dest}}, scalar $cb->($_[1]);
                      }
                      elsif ($t eq 'Hash') {
                          $self->{opt}{$dest} ||= {};
                          $self->{opt}{$dest}{$_[1]} = $cb->($_[2]);
                      }
                      else {
                          $self->{opt}{$dest} = $cb->($_[1]);
                      }
                  };
              }
          }
          else {
              $destination = ref $ref ? $ref : \$self->{opt}{$dest};
          }
          if (exists $opts->{default}) {
              my $value = $opts->{default};
              if (ref $value eq 'ARRAY') {
                  push @$default_args, map {
                      ("--$dest", $_) 
                  } grep { defined $_ } @$value;
              }
              elsif (ref $value eq 'HASH') {
                  push @$default_args, map {
                      (my $key = $_) =~ s/=/\\=/g;
                      ("--$dest" => "$key=$value->{$_}")
                  } grep {
                      defined $value->{$_}  
                  } keys %$value;
              }
              elsif (not ref $value) {
                  if (!$spec || $spec eq '!') {
                      push @$default_args, "--$dest" if $value;
                  }
                  else {
                      push @$default_args, "--$dest", $value if defined $value;
                  }
              }
              else {
                  $self->{error} = "Invalid default option for $dest";
                  $self->{ret} = 0;
              }
              $default_opthash->{$o} = $destination;
          }
          $opthash->{$o} = $destination;
          $self->{requires}{$dest} = $o if $opts->{required};
      }
  
      return if $self->{error};
      if (@$default_args) {
          $self->{ret} = $self->_parse_option($default_args, $default_opthash);
          return unless $self->{ret};
      }
  
      return $opthash;
  }
  
  sub _init_struct {
      my ($self, $struct) = @_;
      $self->{struct} = ref $struct eq 'ARRAY' ? $struct : ref $struct eq 'HASH' ? $self->_normalize_struct($struct) : [];
  
      if (ref $self->{modes} eq 'ARRAY') {
          my @modeopt;
          for my $m (@{$self->{modes}}) {
              my($mc) = $m =~ /^(\w)/;
              push @modeopt, [[$mc, $m], qq($m mode)];
          }
          unshift @$struct, @modeopt;
      }
  
      unshift @{$self->{struct}}, [[qw(h help)], qq(this help message)]
          if $self->{usage} && !$self->_has_option('help');
  }
  
  sub _normalize_struct {
      my ($self, $struct) = @_;
  
      my $result = [];
      for my $option (keys %$struct) {
          my $data = $struct->{$option} || {};
          $data = ref $data eq 'HASH' ? $data : {};
          my $row = [];
          push @$row, [
              $option,
              ref $data->{alias} eq 'ARRAY' ? @{$data->{alias}} :
              defined $data->{alias}        ? $data->{alias}    :  (),
          ];
          push @$row, $data->{desc};
          push @$row, $data->{type};
          push @$row, $data->{dest};
          push @$row, $data->{opts};
          push @$result, $row;
      }
  
      return $result;
  }
  
  sub _compile_spec {
      my ($self, $spec) = @_;
      return if !defined $spec or $spec eq '';
      return $spec if $self->_opt_spec2name($spec);
      my ($type, $cb);
      if ($spec =~ /^(Array|Hash)\[(\w+)\]$/) {
          $type  = $TYPE_MAP->{$2} || Carp::croak("Can't find type constraint '$2'");
          $type .= $1 eq 'Array' ? '@' : '%';
          $cb    = $TYPE_GEN->{$2};
      }
      elsif ($type = $TYPE_MAP->{$spec}) {
          $cb = $TYPE_GEN->{$spec};
      }
      else {
          Carp::croak("Can't find type constraint '$spec'");
      }
      return $type, $cb;
  }
  
  sub add_type {
      my ($class, $name, $src_type, $cb) = @_;
      unless (defined $name && $src_type && ref $cb eq 'CODE') {
          Carp::croak("Usage: $class->add_type(\$name, \$src_type, \$cb)");
      }
      unless ($TYPE_MAP->{$src_type}) {
          Carp::croak("$src_type is not defined src type");
      }
      $TYPE_MAP->{$name} = $TYPE_MAP->{$src_type};
      $TYPE_GEN->{$name} = $cb;
  }
  
  sub _init_summary {
      my ($self, $command_struct) = @_;
      if ($command_struct) {
          for my $key (keys %$command_struct) {
              $self->{summary}{$key} = $command_struct->{$key}->{desc} || '';
          }
      }
      else {
          $self->{summary} = {};
      }
  }
  
  sub _extends_usage {
      my ($self, $command_option) = @_;
      for my $key (qw/args other_usage/) {
          $self->{$key} = $command_option->{$key} if exists $command_option->{$key};
      }
  }
  
  sub _check_requires {
      my ($self) = @_;
      for my $dest (sort keys %{$self->{requires}}) {
          unless (defined $self->{opt}{$dest}) {
              unless (defined ${$self->{parsed_opthash}{$self->{requires}{$dest}}}) {
                  $self->{ret}   = 0;
                  $self->{error} = "`--$dest` option must be specified";
                  return 0;
              }
          }
      }
      return 1;
  }
  
  sub _option_names {
      my($self, $m) = @_;
      my @sorted = sort {
          my ($la, $lb) = (length($a), length($b));
          return $la <=> $lb if $la < 2 or $lb < 2;
          return 0;
      } ref $m eq 'ARRAY' ? @$m : $m;
      return @sorted;
  }
  
  sub _has_option {
      my($self, $option) = @_;
      return 1 if grep { $_ eq $option } map { $self->_option_names($_->[0]) } @{$self->{struct}};
      return 0;
  }
  
  1;
  __END__
  
  =encoding utf-8
  
  =for stopwords
  
  =head1 NAME
  
  Getopt::Compact::WithCmd - sub-command friendly, like Getopt::Compact
  
  =head1 SYNOPSIS
  
  inside foo.pl:
  
    use Getopt::Compact::WithCmd;
    
    my $go = Getopt::Compact::WithCmd->new(
       name          => 'foo',
       version       => '0.1',
       args          => 'FILE',
       global_struct => [
          [ [qw/f force/], 'force overwrite', '!', \my $force ],
       ],
       command_struct => {
          get => {
              options     => [
                  [ [qw/d dir/], 'dest dir', '=s', undef, { default => '.' } ],
                  [ [qw/o output/], 'output file name', '=s', undef, { required => 1 }],
              ],
              desc        => 'get file from url',
              args        => 'url',
              other_usage => 'blah blah blah',
          },
          remove => {
              ...
          }
       },
    );
    
    my $opts = $go->opts;
    my $cmd  = $go->command;
    
    if ($cmd eq 'get') {
        my $url = shift @ARGV;
    }
  
  how will be like this:
  
    $ ./foo.pl -f get -o bar.html http://example.com/
  
  usage, running the command './foo.pl -x' results in the following output:
  
    $ ./foo.pl -x
    Unknown option: x
    foo v0.1
    usage: foo.pl [options] COMMAND FILE
    
    options:
       -h, --help           This help message
       -f, --force   Bool   Force overwrite
    
    Implemented commands are:
       get   Get file from url
    
    See 'foo.pl help COMMAND' for more information on a specific command.
  
  in addition, running the command './foo.pl get' results in the following output:
  
    $ ./foo.pl get
    `--output` option must be specified
    foo v0.1
    usage: foo.pl get [options] url
    
    options:
       -h, --help                                     This help message
       -d, --dir      Str            (default: '.')   Dest dir
       -o, --output   Str (required)                  Output file name
    
    blah blah blah
  
  =head1 DESCRIPTION
  
  Getopt::Compact::WithCmd is yet another Getopt::* module.
  This module is respected L<Getopt::Compact>.
  This module is you can define of git-like option.
  In addition, usage can be set at the same time.
  
  =head1 METHODS
  
  =head2 new(%args)
  
  Create an object.
  The option most Getopt::Compact compatible.
  But I<struct> is cannot use.
  
  The new I<%args> are:
  
  =over
  
  =item C<< global_struct($arrayref) >>
  
  This option is sets common options across commands.
  This option value is Getopt::Compact compatible.
  In addition, extended to other values can be set.
  
    use Getopt::Compact::WithCmd;
    my $go = Getopt::Compact::WithCmd->new(
        global_struct => [
            [ $name_spec_arrayref, $description_scalar, $argument_spec_scalar, \$destination_scalar, $opt_hashref ],
            [ ... ]
        ],
    );
  
  And you can also write in hash style.
  
    use Getopt::Compact::WithCmd;
    my $go = Getopt::Compact::WithCmd->new(
        global_struct => {
            $name_scalar => {
                alias => $name_spec_arrayref,
                desc  => $description_scalar,
                type  => $argument_spec_scalar,
                dest  => \$destination_scalar,
                opts  => $opt_hashref,
            },
            $other_name_scalar => {
                ...
            },
        },
    );
  
  I<$argument_spec_scalar> can be set value are L<< Getopt::Long >>'s option specifications.
  And you can also specify the following readable style:
  
    Bool     # eq !
    Incr     # eq +
    Str      # eq =s
    Int      # eq =i
    Num      # eq =f
    ExNum    # eq =o
  
  In addition, Array and Hash type are:
  
    Array[Str] # eq =s@
    Hash[Int]  # eq =i%
    ...
  
  I<$opt_hasref> are:
  
    {
        default  => $value, # default value
        required => $bool,
    }
  
  =item C<< command_struct($hashref) >>
  
  This option is sets sub-command and options.
  
    use Getopt::Compact::WithCmd;
    my $go = Getopt::Compact::WithCmd->new(
        command_struct => {
            $command => {
                options        => $options,
                args           => $args,
                desc           => $description,
                other_usage    => $other_usage,
                command_struct => $command_struct,
            },
        },
    );
  
  I<$options>
  
  This value is compatible to C<global_struct>.
  
  I<$args>
  
  command args.
  
  I<$description>
  
  command description.
  
  I<$other_usage>
  
  other usage message.
  be added to the end of the usage message.
  
  I<$command_struct>
  
  support nesting.
  
    use Getopt::Compact::WithCmd;
    my $go = Getopt::Compact::WithCmd->new(
        command_struct => {
            $command => {
                options        => $options,
                args           => $args,
                desc           => $description,
                other_usage    => $other_usage,
                command_struct => {
                    $sub_command => {
                        options => ...
                    },
                },
            },
        },
    );
  
    # will run cmd:
    $ ./foo.pl $command $sub_command ...
  
  =back
  
  =head2 add_type($new_type, $src_type, $code_ref);
  
  This method is additional your own type.
  You must be call before new() method.
  
    use JSON;
    use Data::Dumper;
  
    Getopt::Compact::WithCmd->add_type(JSON => Str => sub { decode_json(shift) });
    my $go = Getopt::Compact::WithCmd->new(
        global_struct => {
            from_json => {
                type => 'JSON',
            },
        },
    );
    my $data = $go->opts->{from_json};
    print Dumper $data;
  
    # will run cmd:
    $ ./add_type.pl --from_json '{"foo":"bar"}'
    $VAR1 = {
              'foo' => 'bar'
            };
  
  =head2 new_from_array(\@myopts, %args);
  
  C<< new_from_array >> can be used to parse options from an arbitrary array.
  
    $go = Getopt::Compact::WithCmd->new_from_array(\@myopts, ...);
  
  =head2 new_from_string($option_string, %args);
  
  C<< new_from_string >> can be used to parts options from an arbitrary string.
  
  This method using L<< Text::ParseWords >> on internal.
  
    $go = Getopt::Compact::WithCmd->new_from_string('--foo bar baz', ...);
  
  =head2 opts
  
  Returns a hashref of options keyed by option name.
  Return value is merged global options and command options.
  
  =head2 command
  
  Gets sub-command name.
  
    # inside foo.pl
    use Getopt::Compact::WithCmd;
    
    my $go = Getopt::Compact::WithCmd->new(
       command_struct => {
          bar => {},
       },
    );
    
    print "command: ", $go->command, "\n";
    
    # running the command
    $ ./foo.pl bar
    bar
  
  =head2 commands
  
  Get sub commands. Returned value is ARRAYREF.
  
    # inside foo.pl
    use Getopt::Compact::WithCmd;
    
    my $go = Getopt::Compact::WithCmd->new(
       command_struct => {
          bar => {
              command_struct => {
                  baz => {},
              },
          },
       },
    );
    
    print join(", ", @{$go->commands}), "\n";
    
    # running the command
    $ ./foo.pl bar baz
    bar, baz
  
  =head2 status
  
  This is a true value if the command line was processed successfully. Otherwise it returns a false result.
  
    $go->status ? "success" : "fail";
  
  =head2 is_success
  
  Alias of C<status>
  
    $go->is_success # == $go->status
  
  =head2 usage
  
  Gets usage message.
  
    my $message = $go->usage;
    my $message = $go->usage($target_command_name); # must be implemented command.
  
  =head2 show_usage
  
  Display usage message and exit.
  
    $go->show_usage;
    $go->show_usage($target_command_name);
  
  =head2 error
  
  Return value is an error message or empty string.
  
    $go->error;
  
  =head2 args
  
  Return value is array reference to any remaining arguments.
  
    $go->args # like \@ARGV
  
  =head2 pod2usage
  
  B<Not implemented.>
  
  =head1 AUTHOR
  
  xaicron E<lt>xaicron {at} cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2010 - xaicron
  
  =head1 LICENSE
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<Getopt::Compact>
  
  =cut
GETOPT_COMPACT_WITHCMD

$fatpacked{"Getopt/Long.pm"} = <<'GETOPT_LONG';
  # Getopt::Long.pm -- Universal options parsing
  
  package Getopt::Long;
  
  # RCS Status      : $Id: Long.pm,v 2.76 2009/03/30 20:54:30 jv Exp $
  # Author          : Johan Vromans
  # Created On      : Tue Sep 11 15:00:12 1990
  # Last Modified By: Johan Vromans
  # Last Modified On: Mon Mar 30 22:51:17 2009
  # Update Count    : 1601
  # Status          : Released
  
  ################ Module Preamble ################
  
  use 5.004;
  
  use strict;
  
  use vars qw($VERSION);
  $VERSION        =  2.38;
  # For testing versions only.
  #use vars qw($VERSION_STRING);
  #$VERSION_STRING = "2.38";
  
  use Exporter;
  use vars qw(@ISA @EXPORT @EXPORT_OK);
  @ISA = qw(Exporter);
  
  # Exported subroutines.
  sub GetOptions(@);		# always
  sub GetOptionsFromArray(@);	# on demand
  sub GetOptionsFromString(@);	# on demand
  sub Configure(@);		# on demand
  sub HelpMessage(@);		# on demand
  sub VersionMessage(@);		# in demand
  
  BEGIN {
      # Init immediately so their contents can be used in the 'use vars' below.
      @EXPORT    = qw(&GetOptions $REQUIRE_ORDER $PERMUTE $RETURN_IN_ORDER);
      @EXPORT_OK = qw(&HelpMessage &VersionMessage &Configure
  		    &GetOptionsFromArray &GetOptionsFromString);
  }
  
  # User visible variables.
  use vars @EXPORT, @EXPORT_OK;
  use vars qw($error $debug $major_version $minor_version);
  # Deprecated visible variables.
  use vars qw($autoabbrev $getopt_compat $ignorecase $bundling $order
  	    $passthrough);
  # Official invisible variables.
  use vars qw($genprefix $caller $gnu_compat $auto_help $auto_version $longprefix);
  
  # Public subroutines.
  sub config(@);			# deprecated name
  
  # Private subroutines.
  sub ConfigDefaults();
  sub ParseOptionSpec($$);
  sub OptCtl($);
  sub FindOption($$$$$);
  sub ValidValue ($$$$$);
  
  ################ Local Variables ################
  
  # $requested_version holds the version that was mentioned in the 'use'
  # or 'require', if any. It can be used to enable or disable specific
  # features.
  my $requested_version = 0;
  
  ################ Resident subroutines ################
  
  sub ConfigDefaults() {
      # Handle POSIX compliancy.
      if ( defined $ENV{"POSIXLY_CORRECT"} ) {
  	$genprefix = "(--|-)";
  	$autoabbrev = 0;		# no automatic abbrev of options
  	$bundling = 0;			# no bundling of single letter switches
  	$getopt_compat = 0;		# disallow '+' to start options
  	$order = $REQUIRE_ORDER;
      }
      else {
  	$genprefix = "(--|-|\\+)";
  	$autoabbrev = 1;		# automatic abbrev of options
  	$bundling = 0;			# bundling off by default
  	$getopt_compat = 1;		# allow '+' to start options
  	$order = $PERMUTE;
      }
      # Other configurable settings.
      $debug = 0;			# for debugging
      $error = 0;			# error tally
      $ignorecase = 1;		# ignore case when matching options
      $passthrough = 0;		# leave unrecognized options alone
      $gnu_compat = 0;		# require --opt=val if value is optional
      $longprefix = "(--)";       # what does a long prefix look like
  }
  
  # Override import.
  sub import {
      my $pkg = shift;		# package
      my @syms = ();		# symbols to import
      my @config = ();		# configuration
      my $dest = \@syms;		# symbols first
      for ( @_ ) {
  	if ( $_ eq ':config' ) {
  	    $dest = \@config;	# config next
  	    next;
  	}
  	push(@$dest, $_);	# push
      }
      # Hide one level and call super.
      local $Exporter::ExportLevel = 1;
      push(@syms, qw(&GetOptions)) if @syms; # always export GetOptions
      $pkg->SUPER::import(@syms);
      # And configure.
      Configure(@config) if @config;
  }
  
  ################ Initialization ################
  
  # Values for $order. See GNU getopt.c for details.
  ($REQUIRE_ORDER, $PERMUTE, $RETURN_IN_ORDER) = (0..2);
  # Version major/minor numbers.
  ($major_version, $minor_version) = $VERSION =~ /^(\d+)\.(\d+)/;
  
  ConfigDefaults();
  
  ################ OO Interface ################
  
  package Getopt::Long::Parser;
  
  # Store a copy of the default configuration. Since ConfigDefaults has
  # just been called, what we get from Configure is the default.
  my $default_config = do {
      Getopt::Long::Configure ()
  };
  
  sub new {
      my $that = shift;
      my $class = ref($that) || $that;
      my %atts = @_;
  
      # Register the callers package.
      my $self = { caller_pkg => (caller)[0] };
  
      bless ($self, $class);
  
      # Process config attributes.
      if ( defined $atts{config} ) {
  	my $save = Getopt::Long::Configure ($default_config, @{$atts{config}});
  	$self->{settings} = Getopt::Long::Configure ($save);
  	delete ($atts{config});
      }
      # Else use default config.
      else {
  	$self->{settings} = $default_config;
      }
  
      if ( %atts ) {		# Oops
  	die(__PACKAGE__.": unhandled attributes: ".
  	    join(" ", sort(keys(%atts)))."\n");
      }
  
      $self;
  }
  
  sub configure {
      my ($self) = shift;
  
      # Restore settings, merge new settings in.
      my $save = Getopt::Long::Configure ($self->{settings}, @_);
  
      # Restore orig config and save the new config.
      $self->{settings} = Getopt::Long::Configure ($save);
  }
  
  sub getoptions {
      my ($self) = shift;
  
      # Restore config settings.
      my $save = Getopt::Long::Configure ($self->{settings});
  
      # Call main routine.
      my $ret = 0;
      $Getopt::Long::caller = $self->{caller_pkg};
  
      eval {
  	# Locally set exception handler to default, otherwise it will
  	# be called implicitly here, and again explicitly when we try
  	# to deliver the messages.
  	local ($SIG{__DIE__}) = 'DEFAULT';
  	$ret = Getopt::Long::GetOptions (@_);
      };
  
      # Restore saved settings.
      Getopt::Long::Configure ($save);
  
      # Handle errors and return value.
      die ($@) if $@;
      return $ret;
  }
  
  package Getopt::Long;
  
  ################ Back to Normal ################
  
  # Indices in option control info.
  # Note that ParseOptions uses the fields directly. Search for 'hard-wired'.
  use constant CTL_TYPE    => 0;
  #use constant   CTL_TYPE_FLAG   => '';
  #use constant   CTL_TYPE_NEG    => '!';
  #use constant   CTL_TYPE_INCR   => '+';
  #use constant   CTL_TYPE_INT    => 'i';
  #use constant   CTL_TYPE_INTINC => 'I';
  #use constant   CTL_TYPE_XINT   => 'o';
  #use constant   CTL_TYPE_FLOAT  => 'f';
  #use constant   CTL_TYPE_STRING => 's';
  
  use constant CTL_CNAME   => 1;
  
  use constant CTL_DEFAULT => 2;
  
  use constant CTL_DEST    => 3;
   use constant   CTL_DEST_SCALAR => 0;
   use constant   CTL_DEST_ARRAY  => 1;
   use constant   CTL_DEST_HASH   => 2;
   use constant   CTL_DEST_CODE   => 3;
  
  use constant CTL_AMIN    => 4;
  use constant CTL_AMAX    => 5;
  
  # FFU.
  #use constant CTL_RANGE   => ;
  #use constant CTL_REPEAT  => ;
  
  # Rather liberal patterns to match numbers.
  use constant PAT_INT   => "[-+]?_*[0-9][0-9_]*";
  use constant PAT_XINT  =>
    "(?:".
  	  "[-+]?_*[1-9][0-9_]*".
    "|".
  	  "0x_*[0-9a-f][0-9a-f_]*".
    "|".
  	  "0b_*[01][01_]*".
    "|".
  	  "0[0-7_]*".
    ")";
  use constant PAT_FLOAT => "[-+]?[0-9._]+(\.[0-9_]+)?([eE][-+]?[0-9_]+)?";
  
  sub GetOptions(@) {
      # Shift in default array.
      unshift(@_, \@ARGV);
      # Try to keep caller() and Carp consitent.
      goto &GetOptionsFromArray;
  }
  
  sub GetOptionsFromString(@) {
      my ($string) = shift;
      require Text::ParseWords;
      my $args = [ Text::ParseWords::shellwords($string) ];
      $caller ||= (caller)[0];	# current context
      my $ret = GetOptionsFromArray($args, @_);
      return ( $ret, $args ) if wantarray;
      if ( @$args ) {
  	$ret = 0;
  	warn("GetOptionsFromString: Excess data \"@$args\" in string \"$string\"\n");
      }
      $ret;
  }
  
  sub GetOptionsFromArray(@) {
  
      my ($argv, @optionlist) = @_;	# local copy of the option descriptions
      my $argend = '--';		# option list terminator
      my %opctl = ();		# table of option specs
      my $pkg = $caller || (caller)[0];	# current context
  				# Needed if linkage is omitted.
      my @ret = ();		# accum for non-options
      my %linkage;		# linkage
      my $userlinkage;		# user supplied HASH
      my $opt;			# current option
      my $prefix = $genprefix;	# current prefix
  
      $error = '';
  
      if ( $debug ) {
  	# Avoid some warnings if debugging.
  	local ($^W) = 0;
  	print STDERR
  	  ("Getopt::Long $Getopt::Long::VERSION (",
  	   '$Revision: 2.76 $', ") ",
  	   "called from package \"$pkg\".",
  	   "\n  ",
  	   "argv: (@$argv)",
  	   "\n  ",
  	   "autoabbrev=$autoabbrev,".
  	   "bundling=$bundling,",
  	   "getopt_compat=$getopt_compat,",
  	   "gnu_compat=$gnu_compat,",
  	   "order=$order,",
  	   "\n  ",
  	   "ignorecase=$ignorecase,",
  	   "requested_version=$requested_version,",
  	   "passthrough=$passthrough,",
  	   "genprefix=\"$genprefix\",",
  	   "longprefix=\"$longprefix\".",
  	   "\n");
      }
  
      # Check for ref HASH as first argument.
      # First argument may be an object. It's OK to use this as long
      # as it is really a hash underneath.
      $userlinkage = undef;
      if ( @optionlist && ref($optionlist[0]) and
  	 UNIVERSAL::isa($optionlist[0],'HASH') ) {
  	$userlinkage = shift (@optionlist);
  	print STDERR ("=> user linkage: $userlinkage\n") if $debug;
      }
  
      # See if the first element of the optionlist contains option
      # starter characters.
      # Be careful not to interpret '<>' as option starters.
      if ( @optionlist && $optionlist[0] =~ /^\W+$/
  	 && !($optionlist[0] eq '<>'
  	      && @optionlist > 0
  	      && ref($optionlist[1])) ) {
  	$prefix = shift (@optionlist);
  	# Turn into regexp. Needs to be parenthesized!
  	$prefix =~ s/(\W)/\\$1/g;
  	$prefix = "([" . $prefix . "])";
  	print STDERR ("=> prefix=\"$prefix\"\n") if $debug;
      }
  
      # Verify correctness of optionlist.
      %opctl = ();
      while ( @optionlist ) {
  	my $opt = shift (@optionlist);
  
  	unless ( defined($opt) ) {
  	    $error .= "Undefined argument in option spec\n";
  	    next;
  	}
  
  	# Strip leading prefix so people can specify "--foo=i" if they like.
  	$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  
  	if ( $opt eq '<>' ) {
  	    if ( (defined $userlinkage)
  		&& !(@optionlist > 0 && ref($optionlist[0]))
  		&& (exists $userlinkage->{$opt})
  		&& ref($userlinkage->{$opt}) ) {
  		unshift (@optionlist, $userlinkage->{$opt});
  	    }
  	    unless ( @optionlist > 0
  		    && ref($optionlist[0]) && ref($optionlist[0]) eq 'CODE' ) {
  		$error .= "Option spec <> requires a reference to a subroutine\n";
  		# Kill the linkage (to avoid another error).
  		shift (@optionlist)
  		  if @optionlist && ref($optionlist[0]);
  		next;
  	    }
  	    $linkage{'<>'} = shift (@optionlist);
  	    next;
  	}
  
  	# Parse option spec.
  	my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  	unless ( defined $name ) {
  	    # Failed. $orig contains the error message. Sorry for the abuse.
  	    $error .= $orig;
  	    # Kill the linkage (to avoid another error).
  	    shift (@optionlist)
  	      if @optionlist && ref($optionlist[0]);
  	    next;
  	}
  
  	# If no linkage is supplied in the @optionlist, copy it from
  	# the userlinkage if available.
  	if ( defined $userlinkage ) {
  	    unless ( @optionlist > 0 && ref($optionlist[0]) ) {
  		if ( exists $userlinkage->{$orig} &&
  		     ref($userlinkage->{$orig}) ) {
  		    print STDERR ("=> found userlinkage for \"$orig\": ",
  				  "$userlinkage->{$orig}\n")
  			if $debug;
  		    unshift (@optionlist, $userlinkage->{$orig});
  		}
  		else {
  		    # Do nothing. Being undefined will be handled later.
  		    next;
  		}
  	    }
  	}
  
  	# Copy the linkage. If omitted, link to global variable.
  	if ( @optionlist > 0 && ref($optionlist[0]) ) {
  	    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  		if $debug;
  	    my $rl = ref($linkage{$orig} = shift (@optionlist));
  
  	    if ( $rl eq "ARRAY" ) {
  		$opctl{$name}[CTL_DEST] = CTL_DEST_ARRAY;
  	    }
  	    elsif ( $rl eq "HASH" ) {
  		$opctl{$name}[CTL_DEST] = CTL_DEST_HASH;
  	    }
  	    elsif ( $rl eq "SCALAR" || $rl eq "REF" ) {
  #		if ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY ) {
  #		    my $t = $linkage{$orig};
  #		    $$t = $linkage{$orig} = [];
  #		}
  #		elsif ( $opctl{$name}[CTL_DEST] == CTL_DEST_HASH ) {
  #		}
  #		else {
  		    # Ok.
  #		}
  	    }
  	    elsif ( $rl eq "CODE" ) {
  		# Ok.
  	    }
  	    else {
  		$error .= "Invalid option linkage for \"$opt\"\n";
  	    }
  	}
  	else {
  	    # Link to global $opt_XXX variable.
  	    # Make sure a valid perl identifier results.
  	    my $ov = $orig;
  	    $ov =~ s/\W/_/g;
  	    if ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY ) {
  		print STDERR ("=> link \"$orig\" to \@$pkg","::opt_$ov\n")
  		    if $debug;
  		eval ("\$linkage{\$orig} = \\\@".$pkg."::opt_$ov;");
  	    }
  	    elsif ( $opctl{$name}[CTL_DEST] == CTL_DEST_HASH ) {
  		print STDERR ("=> link \"$orig\" to \%$pkg","::opt_$ov\n")
  		    if $debug;
  		eval ("\$linkage{\$orig} = \\\%".$pkg."::opt_$ov;");
  	    }
  	    else {
  		print STDERR ("=> link \"$orig\" to \$$pkg","::opt_$ov\n")
  		    if $debug;
  		eval ("\$linkage{\$orig} = \\\$".$pkg."::opt_$ov;");
  	    }
  	}
  
  	if ( $opctl{$name}[CTL_TYPE] eq 'I'
  	     && ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY
  		  || $opctl{$name}[CTL_DEST] == CTL_DEST_HASH )
  	   ) {
  	    $error .= "Invalid option linkage for \"$opt\"\n";
  	}
  
      }
  
      # Bail out if errors found.
      die ($error) if $error;
      $error = 0;
  
      # Supply --version and --help support, if needed and allowed.
      if ( defined($auto_version) ? $auto_version : ($requested_version >= 2.3203) ) {
  	if ( !defined($opctl{version}) ) {
  	    $opctl{version} = ['','version',0,CTL_DEST_CODE,undef];
  	    $linkage{version} = \&VersionMessage;
  	}
  	$auto_version = 1;
      }
      if ( defined($auto_help) ? $auto_help : ($requested_version >= 2.3203) ) {
  	if ( !defined($opctl{help}) && !defined($opctl{'?'}) ) {
  	    $opctl{help} = $opctl{'?'} = ['','help',0,CTL_DEST_CODE,undef];
  	    $linkage{help} = \&HelpMessage;
  	}
  	$auto_help = 1;
      }
  
      # Show the options tables if debugging.
      if ( $debug ) {
  	my ($arrow, $k, $v);
  	$arrow = "=> ";
  	while ( ($k,$v) = each(%opctl) ) {
  	    print STDERR ($arrow, "\$opctl{$k} = $v ", OptCtl($v), "\n");
  	    $arrow = "   ";
  	}
      }
  
      # Process argument list
      my $goon = 1;
      while ( $goon && @$argv > 0 ) {
  
  	# Get next argument.
  	$opt = shift (@$argv);
  	print STDERR ("=> arg \"", $opt, "\"\n") if $debug;
  
  	# Double dash is option list terminator.
  	if ( $opt eq $argend ) {
  	  push (@ret, $argend) if $passthrough;
  	  last;
  	}
  
  	# Look it up.
  	my $tryopt = $opt;
  	my $found;		# success status
  	my $key;		# key (if hash type)
  	my $arg;		# option argument
  	my $ctl;		# the opctl entry
  
  	($found, $opt, $ctl, $arg, $key) =
  	  FindOption ($argv, $prefix, $argend, $opt, \%opctl);
  
  	if ( $found ) {
  
  	    # FindOption undefines $opt in case of errors.
  	    next unless defined $opt;
  
  	    my $argcnt = 0;
  	    while ( defined $arg ) {
  
  		# Get the canonical name.
  		print STDERR ("=> cname for \"$opt\" is ") if $debug;
  		$opt = $ctl->[CTL_CNAME];
  		print STDERR ("\"$ctl->[CTL_CNAME]\"\n") if $debug;
  
  		if ( defined $linkage{$opt} ) {
  		    print STDERR ("=> ref(\$L{$opt}) -> ",
  				  ref($linkage{$opt}), "\n") if $debug;
  
  		    if ( ref($linkage{$opt}) eq 'SCALAR'
  			 || ref($linkage{$opt}) eq 'REF' ) {
  			if ( $ctl->[CTL_TYPE] eq '+' ) {
  			    print STDERR ("=> \$\$L{$opt} += \"$arg\"\n")
  			      if $debug;
  			    if ( defined ${$linkage{$opt}} ) {
  			        ${$linkage{$opt}} += $arg;
  			    }
  		            else {
  			        ${$linkage{$opt}} = $arg;
  			    }
  			}
  			elsif ( $ctl->[CTL_DEST] == CTL_DEST_ARRAY ) {
  			    print STDERR ("=> ref(\$L{$opt}) auto-vivified",
  					  " to ARRAY\n")
  			      if $debug;
  			    my $t = $linkage{$opt};
  			    $$t = $linkage{$opt} = [];
  			    print STDERR ("=> push(\@{\$L{$opt}, \"$arg\")\n")
  			      if $debug;
  			    push (@{$linkage{$opt}}, $arg);
  			}
  			elsif ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
  			    print STDERR ("=> ref(\$L{$opt}) auto-vivified",
  					  " to HASH\n")
  			      if $debug;
  			    my $t = $linkage{$opt};
  			    $$t = $linkage{$opt} = {};
  			    print STDERR ("=> \$\$L{$opt}->{$key} = \"$arg\"\n")
  			      if $debug;
  			    $linkage{$opt}->{$key} = $arg;
  			}
  			else {
  			    print STDERR ("=> \$\$L{$opt} = \"$arg\"\n")
  			      if $debug;
  			    ${$linkage{$opt}} = $arg;
  		        }
  		    }
  		    elsif ( ref($linkage{$opt}) eq 'ARRAY' ) {
  			print STDERR ("=> push(\@{\$L{$opt}, \"$arg\")\n")
  			    if $debug;
  			push (@{$linkage{$opt}}, $arg);
  		    }
  		    elsif ( ref($linkage{$opt}) eq 'HASH' ) {
  			print STDERR ("=> \$\$L{$opt}->{$key} = \"$arg\"\n")
  			    if $debug;
  			$linkage{$opt}->{$key} = $arg;
  		    }
  		    elsif ( ref($linkage{$opt}) eq 'CODE' ) {
  			print STDERR ("=> &L{$opt}(\"$opt\"",
  				      $ctl->[CTL_DEST] == CTL_DEST_HASH ? ", \"$key\"" : "",
  				      ", \"$arg\")\n")
  			    if $debug;
  			my $eval_error = do {
  			    local $@;
  			    local $SIG{__DIE__}  = 'DEFAULT';
  			    eval {
  				&{$linkage{$opt}}
  				  (Getopt::Long::CallBack->new
  				   (name    => $opt,
  				    ctl     => $ctl,
  				    opctl   => \%opctl,
  				    linkage => \%linkage,
  				    prefix  => $prefix,
  				   ),
  				   $ctl->[CTL_DEST] == CTL_DEST_HASH ? ($key) : (),
  				   $arg);
  			    };
  			    $@;
  			};
  			print STDERR ("=> die($eval_error)\n")
  			  if $debug && $eval_error ne '';
  			if ( $eval_error =~ /^!/ ) {
  			    if ( $eval_error =~ /^!FINISH\b/ ) {
  				$goon = 0;
  			    }
  			}
  			elsif ( $eval_error ne '' ) {
  			    warn ($eval_error);
  			    $error++;
  			}
  		    }
  		    else {
  			print STDERR ("Invalid REF type \"", ref($linkage{$opt}),
  				      "\" in linkage\n");
  			die("Getopt::Long -- internal error!\n");
  		    }
  		}
  		# No entry in linkage means entry in userlinkage.
  		elsif ( $ctl->[CTL_DEST] == CTL_DEST_ARRAY ) {
  		    if ( defined $userlinkage->{$opt} ) {
  			print STDERR ("=> push(\@{\$L{$opt}}, \"$arg\")\n")
  			    if $debug;
  			push (@{$userlinkage->{$opt}}, $arg);
  		    }
  		    else {
  			print STDERR ("=>\$L{$opt} = [\"$arg\"]\n")
  			    if $debug;
  			$userlinkage->{$opt} = [$arg];
  		    }
  		}
  		elsif ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
  		    if ( defined $userlinkage->{$opt} ) {
  			print STDERR ("=> \$L{$opt}->{$key} = \"$arg\"\n")
  			    if $debug;
  			$userlinkage->{$opt}->{$key} = $arg;
  		    }
  		    else {
  			print STDERR ("=>\$L{$opt} = {$key => \"$arg\"}\n")
  			    if $debug;
  			$userlinkage->{$opt} = {$key => $arg};
  		    }
  		}
  		else {
  		    if ( $ctl->[CTL_TYPE] eq '+' ) {
  			print STDERR ("=> \$L{$opt} += \"$arg\"\n")
  			  if $debug;
  			if ( defined $userlinkage->{$opt} ) {
  			    $userlinkage->{$opt} += $arg;
  			}
  			else {
  			    $userlinkage->{$opt} = $arg;
  			}
  		    }
  		    else {
  			print STDERR ("=>\$L{$opt} = \"$arg\"\n") if $debug;
  			$userlinkage->{$opt} = $arg;
  		    }
  		}
  
  		$argcnt++;
  		last if $argcnt >= $ctl->[CTL_AMAX] && $ctl->[CTL_AMAX] != -1;
  		undef($arg);
  
  		# Need more args?
  		if ( $argcnt < $ctl->[CTL_AMIN] ) {
  		    if ( @$argv ) {
  			if ( ValidValue($ctl, $argv->[0], 1, $argend, $prefix) ) {
  			    $arg = shift(@$argv);
  			    $arg =~ tr/_//d if $ctl->[CTL_TYPE] =~ /^[iIo]$/;
  			    ($key,$arg) = $arg =~ /^([^=]+)=(.*)/
  			      if $ctl->[CTL_DEST] == CTL_DEST_HASH;
  			    next;
  			}
  			warn("Value \"$$argv[0]\" invalid for option $opt\n");
  			$error++;
  		    }
  		    else {
  			warn("Insufficient arguments for option $opt\n");
  			$error++;
  		    }
  		}
  
  		# Any more args?
  		if ( @$argv && ValidValue($ctl, $argv->[0], 0, $argend, $prefix) ) {
  		    $arg = shift(@$argv);
  		    $arg =~ tr/_//d if $ctl->[CTL_TYPE] =~ /^[iIo]$/;
  		    ($key,$arg) = $arg =~ /^([^=]+)=(.*)/
  		      if $ctl->[CTL_DEST] == CTL_DEST_HASH;
  		    next;
  		}
  	    }
  	}
  
  	# Not an option. Save it if we $PERMUTE and don't have a <>.
  	elsif ( $order == $PERMUTE ) {
  	    # Try non-options call-back.
  	    my $cb;
  	    if ( (defined ($cb = $linkage{'<>'})) ) {
  		print STDERR ("=> &L{$tryopt}(\"$tryopt\")\n")
  		  if $debug;
  		my $eval_error = do {
  		    local $@;
  		    local $SIG{__DIE__}  = 'DEFAULT';
  		    eval {
  			&$cb
  			  (Getopt::Long::CallBack->new
  			   (name    => $tryopt,
  			    ctl     => $ctl,
  			    opctl   => \%opctl,
  			    linkage => \%linkage,
  			    prefix  => $prefix,
  			   ));
  		    };
  		    $@;
  		};
  		print STDERR ("=> die($eval_error)\n")
  		  if $debug && $eval_error ne '';
  		if ( $eval_error =~ /^!/ ) {
  		    if ( $eval_error =~ /^!FINISH\b/ ) {
  			$goon = 0;
  		    }
  		}
  		elsif ( $eval_error ne '' ) {
  		    warn ($eval_error);
  		    $error++;
  		}
  	    }
  	    else {
  		print STDERR ("=> saving \"$tryopt\" ",
  			      "(not an option, may permute)\n") if $debug;
  		push (@ret, $tryopt);
  	    }
  	    next;
  	}
  
  	# ...otherwise, terminate.
  	else {
  	    # Push this one back and exit.
  	    unshift (@$argv, $tryopt);
  	    return ($error == 0);
  	}
  
      }
  
      # Finish.
      if ( @ret && $order == $PERMUTE ) {
  	#  Push back accumulated arguments
  	print STDERR ("=> restoring \"", join('" "', @ret), "\"\n")
  	    if $debug;
  	unshift (@$argv, @ret);
      }
  
      return ($error == 0);
  }
  
  # A readable representation of what's in an optbl.
  sub OptCtl ($) {
      my ($v) = @_;
      my @v = map { defined($_) ? ($_) : ("<undef>") } @$v;
      "[".
        join(",",
  	   "\"$v[CTL_TYPE]\"",
  	   "\"$v[CTL_CNAME]\"",
  	   "\"$v[CTL_DEFAULT]\"",
  	   ("\$","\@","\%","\&")[$v[CTL_DEST] || 0],
  	   $v[CTL_AMIN] || '',
  	   $v[CTL_AMAX] || '',
  #	   $v[CTL_RANGE] || '',
  #	   $v[CTL_REPEAT] || '',
  	  ). "]";
  }
  
  # Parse an option specification and fill the tables.
  sub ParseOptionSpec ($$) {
      my ($opt, $opctl) = @_;
  
      # Match option spec.
      if ( $opt !~ m;^
  		   (
  		     # Option name
  		     (?: \w+[-\w]* )
  		     # Alias names, or "?"
  		     (?: \| (?: \? | \w[-\w]* ) )*
  		   )?
  		   (
  		     # Either modifiers ...
  		     [!+]
  		     |
  		     # ... or a value/dest/repeat specification
  		     [=:] [ionfs] [@%]? (?: \{\d*,?\d*\} )?
  		     |
  		     # ... or an optional-with-default spec
  		     : (?: -?\d+ | \+ ) [@%]?
  		   )?
  		   $;x ) {
  	return (undef, "Error in option spec: \"$opt\"\n");
      }
  
      my ($names, $spec) = ($1, $2);
      $spec = '' unless defined $spec;
  
      # $orig keeps track of the primary name the user specified.
      # This name will be used for the internal or external linkage.
      # In other words, if the user specifies "FoO|BaR", it will
      # match any case combinations of 'foo' and 'bar', but if a global
      # variable needs to be set, it will be $opt_FoO in the exact case
      # as specified.
      my $orig;
  
      my @names;
      if ( defined $names ) {
  	@names =  split (/\|/, $names);
  	$orig = $names[0];
      }
      else {
  	@names = ('');
  	$orig = '';
      }
  
      # Construct the opctl entries.
      my $entry;
      if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
  	# Fields are hard-wired here.
  	$entry = [$spec,$orig,undef,CTL_DEST_SCALAR,0,0];
      }
      elsif ( $spec =~ /^:(-?\d+|\+)([@%])?$/ ) {
  	my $def = $1;
  	my $dest = $2;
  	my $type = $def eq '+' ? 'I' : 'i';
  	$dest ||= '$';
  	$dest = $dest eq '@' ? CTL_DEST_ARRAY
  	  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
  	# Fields are hard-wired here.
  	$entry = [$type,$orig,$def eq '+' ? undef : $def,
  		  $dest,0,1];
      }
      else {
  	my ($mand, $type, $dest) =
  	  $spec =~ /^([=:])([ionfs])([@%])?(\{(\d+)?(,)?(\d+)?\})?$/;
  	return (undef, "Cannot repeat while bundling: \"$opt\"\n")
  	  if $bundling && defined($4);
  	my ($mi, $cm, $ma) = ($5, $6, $7);
  	return (undef, "{0} is useless in option spec: \"$opt\"\n")
  	  if defined($mi) && !$mi && !defined($ma) && !defined($cm);
  
  	$type = 'i' if $type eq 'n';
  	$dest ||= '$';
  	$dest = $dest eq '@' ? CTL_DEST_ARRAY
  	  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
  	# Default minargs to 1/0 depending on mand status.
  	$mi = $mand eq '=' ? 1 : 0 unless defined $mi;
  	# Adjust mand status according to minargs.
  	$mand = $mi ? '=' : ':';
  	# Adjust maxargs.
  	$ma = $mi ? $mi : 1 unless defined $ma || defined $cm;
  	return (undef, "Max must be greater than zero in option spec: \"$opt\"\n")
  	  if defined($ma) && !$ma;
  	return (undef, "Max less than min in option spec: \"$opt\"\n")
  	  if defined($ma) && $ma < $mi;
  
  	# Fields are hard-wired here.
  	$entry = [$type,$orig,undef,$dest,$mi,$ma||-1];
      }
  
      # Process all names. First is canonical, the rest are aliases.
      my $dups = '';
      foreach ( @names ) {
  
  	$_ = lc ($_)
  	  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
  
  	if ( exists $opctl->{$_} ) {
  	    $dups .= "Duplicate specification \"$opt\" for option \"$_\"\n";
  	}
  
  	if ( $spec eq '!' ) {
  	    $opctl->{"no$_"} = $entry;
  	    $opctl->{"no-$_"} = $entry;
  	    $opctl->{$_} = [@$entry];
  	    $opctl->{$_}->[CTL_TYPE] = '';
  	}
  	else {
  	    $opctl->{$_} = $entry;
  	}
      }
  
      if ( $dups && $^W ) {
  	foreach ( split(/\n+/, $dups) ) {
  	    warn($_."\n");
  	}
      }
      ($names[0], $orig);
  }
  
  # Option lookup.
  sub FindOption ($$$$$) {
  
      # returns (1, $opt, $ctl, $arg, $key) if okay,
      # returns (1, undef) if option in error,
      # returns (0) otherwise.
  
      my ($argv, $prefix, $argend, $opt, $opctl) = @_;
  
      print STDERR ("=> find \"$opt\"\n") if $debug;
  
      return (0) unless $opt =~ /^$prefix(.*)$/s;
      return (0) if $opt eq "-" && !defined $opctl->{''};
  
      $opt = $+;
      my $starter = $1;
  
      print STDERR ("=> split \"$starter\"+\"$opt\"\n") if $debug;
  
      my $optarg;			# value supplied with --opt=value
      my $rest;			# remainder from unbundling
  
      # If it is a long option, it may include the value.
      # With getopt_compat, only if not bundling.
      if ( ($starter=~/^$longprefix$/
            || ($getopt_compat && ($bundling == 0 || $bundling == 2)))
  	  && $opt =~ /^([^=]+)=(.*)$/s ) {
  	$opt = $1;
  	$optarg = $2;
  	print STDERR ("=> option \"", $opt,
  		      "\", optarg = \"$optarg\"\n") if $debug;
      }
  
      #### Look it up ###
  
      my $tryopt = $opt;		# option to try
  
      if ( $bundling && $starter eq '-' ) {
  
  	# To try overrides, obey case ignore.
  	$tryopt = $ignorecase ? lc($opt) : $opt;
  
  	# If bundling == 2, long options can override bundles.
  	if ( $bundling == 2 && length($tryopt) > 1
  	     && defined ($opctl->{$tryopt}) ) {
  	    print STDERR ("=> $starter$tryopt overrides unbundling\n")
  	      if $debug;
  	}
  	else {
  	    $tryopt = $opt;
  	    # Unbundle single letter option.
  	    $rest = length ($tryopt) > 0 ? substr ($tryopt, 1) : '';
  	    $tryopt = substr ($tryopt, 0, 1);
  	    $tryopt = lc ($tryopt) if $ignorecase > 1;
  	    print STDERR ("=> $starter$tryopt unbundled from ",
  			  "$starter$tryopt$rest\n") if $debug;
  	    $rest = undef unless $rest ne '';
  	}
      }
  
      # Try auto-abbreviation.
      elsif ( $autoabbrev && $opt ne "" ) {
  	# Sort the possible long option names.
  	my @names = sort(keys (%$opctl));
  	# Downcase if allowed.
  	$opt = lc ($opt) if $ignorecase;
  	$tryopt = $opt;
  	# Turn option name into pattern.
  	my $pat = quotemeta ($opt);
  	# Look up in option names.
  	my @hits = grep (/^$pat/, @names);
  	print STDERR ("=> ", scalar(@hits), " hits (@hits) with \"$pat\" ",
  		      "out of ", scalar(@names), "\n") if $debug;
  
  	# Check for ambiguous results.
  	unless ( (@hits <= 1) || (grep ($_ eq $opt, @hits) == 1) ) {
  	    # See if all matches are for the same option.
  	    my %hit;
  	    foreach ( @hits ) {
  		my $hit = $_;
  		$hit = $opctl->{$hit}->[CTL_CNAME]
  		  if defined $opctl->{$hit}->[CTL_CNAME];
  		$hit{$hit} = 1;
  	    }
  	    # Remove auto-supplied options (version, help).
  	    if ( keys(%hit) == 2 ) {
  		if ( $auto_version && exists($hit{version}) ) {
  		    delete $hit{version};
  		}
  		elsif ( $auto_help && exists($hit{help}) ) {
  		    delete $hit{help};
  		}
  	    }
  	    # Now see if it really is ambiguous.
  	    unless ( keys(%hit) == 1 ) {
  		return (0) if $passthrough;
  		warn ("Option ", $opt, " is ambiguous (",
  		      join(", ", @hits), ")\n");
  		$error++;
  		return (1, undef);
  	    }
  	    @hits = keys(%hit);
  	}
  
  	# Complete the option name, if appropriate.
  	if ( @hits == 1 && $hits[0] ne $opt ) {
  	    $tryopt = $hits[0];
  	    $tryopt = lc ($tryopt) if $ignorecase;
  	    print STDERR ("=> option \"$opt\" -> \"$tryopt\"\n")
  		if $debug;
  	}
      }
  
      # Map to all lowercase if ignoring case.
      elsif ( $ignorecase ) {
  	$tryopt = lc ($opt);
      }
  
      # Check validity by fetching the info.
      my $ctl = $opctl->{$tryopt};
      unless  ( defined $ctl ) {
  	return (0) if $passthrough;
  	# Pretend one char when bundling.
  	if ( $bundling == 1 && length($starter) == 1 ) {
  	    $opt = substr($opt,0,1);
              unshift (@$argv, $starter.$rest) if defined $rest;
  	}
  	if ( $opt eq "" ) {
  	    warn ("Missing option after ", $starter, "\n");
  	}
  	else {
  	    warn ("Unknown option: ", $opt, "\n");
  	}
  	$error++;
  	return (1, undef);
      }
      # Apparently valid.
      $opt = $tryopt;
      print STDERR ("=> found ", OptCtl($ctl),
  		  " for \"", $opt, "\"\n") if $debug;
  
      #### Determine argument status ####
  
      # If it is an option w/o argument, we're almost finished with it.
      my $type = $ctl->[CTL_TYPE];
      my $arg;
  
      if ( $type eq '' || $type eq '!' || $type eq '+' ) {
  	if ( defined $optarg ) {
  	    return (0) if $passthrough;
  	    warn ("Option ", $opt, " does not take an argument\n");
  	    $error++;
  	    undef $opt;
  	}
  	elsif ( $type eq '' || $type eq '+' ) {
  	    # Supply explicit value.
  	    $arg = 1;
  	}
  	else {
  	    $opt =~ s/^no-?//i;	# strip NO prefix
  	    $arg = 0;		# supply explicit value
  	}
  	unshift (@$argv, $starter.$rest) if defined $rest;
  	return (1, $opt, $ctl, $arg);
      }
  
      # Get mandatory status and type info.
      my $mand = $ctl->[CTL_AMIN];
  
      # Check if there is an option argument available.
      if ( $gnu_compat && defined $optarg && $optarg eq '' ) {
  	return (1, $opt, $ctl, $type eq 's' ? '' : 0) ;#unless $mand;
  	$optarg = 0 unless $type eq 's';
      }
  
      # Check if there is an option argument available.
      if ( defined $optarg
  	 ? ($optarg eq '')
  	 : !(defined $rest || @$argv > 0) ) {
  	# Complain if this option needs an argument.
  #	if ( $mand && !($type eq 's' ? defined($optarg) : 0) ) {
  	if ( $mand ) {
  	    return (0) if $passthrough;
  	    warn ("Option ", $opt, " requires an argument\n");
  	    $error++;
  	    return (1, undef);
  	}
  	if ( $type eq 'I' ) {
  	    # Fake incremental type.
  	    my @c = @$ctl;
  	    $c[CTL_TYPE] = '+';
  	    return (1, $opt, \@c, 1);
  	}
  	return (1, $opt, $ctl,
  		defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] :
  		$type eq 's' ? '' : 0);
      }
  
      # Get (possibly optional) argument.
      $arg = (defined $rest ? $rest
  	    : (defined $optarg ? $optarg : shift (@$argv)));
  
      # Get key if this is a "name=value" pair for a hash option.
      my $key;
      if ($ctl->[CTL_DEST] == CTL_DEST_HASH && defined $arg) {
  	($key, $arg) = ($arg =~ /^([^=]*)=(.*)$/s) ? ($1, $2)
  	  : ($arg, defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] :
  	     ($mand ? undef : ($type eq 's' ? "" : 1)));
  	if (! defined $arg) {
  	    warn ("Option $opt, key \"$key\", requires a value\n");
  	    $error++;
  	    # Push back.
  	    unshift (@$argv, $starter.$rest) if defined $rest;
  	    return (1, undef);
  	}
      }
  
      #### Check if the argument is valid for this option ####
  
      my $key_valid = $ctl->[CTL_DEST] == CTL_DEST_HASH ? "[^=]+=" : "";
  
      if ( $type eq 's' ) {	# string
  	# A mandatory string takes anything.
  	return (1, $opt, $ctl, $arg, $key) if $mand;
  
  	# Same for optional string as a hash value
  	return (1, $opt, $ctl, $arg, $key)
  	  if $ctl->[CTL_DEST] == CTL_DEST_HASH;
  
  	# An optional string takes almost anything.
  	return (1, $opt, $ctl, $arg, $key)
  	  if defined $optarg || defined $rest;
  	return (1, $opt, $ctl, $arg, $key) if $arg eq "-"; # ??
  
  	# Check for option or option list terminator.
  	if ($arg eq $argend ||
  	    $arg =~ /^$prefix.+/) {
  	    # Push back.
  	    unshift (@$argv, $arg);
  	    # Supply empty value.
  	    $arg = '';
  	}
      }
  
      elsif ( $type eq 'i'	# numeric/integer
              || $type eq 'I'	# numeric/integer w/ incr default
  	    || $type eq 'o' ) { # dec/oct/hex/bin value
  
  	my $o_valid = $type eq 'o' ? PAT_XINT : PAT_INT;
  
  	if ( $bundling && defined $rest
  	     && $rest =~ /^($key_valid)($o_valid)(.*)$/si ) {
  	    ($key, $arg, $rest) = ($1, $2, $+);
  	    chop($key) if $key;
  	    $arg = ($type eq 'o' && $arg =~ /^0/) ? oct($arg) : 0+$arg;
  	    unshift (@$argv, $starter.$rest) if defined $rest && $rest ne '';
  	}
  	elsif ( $arg =~ /^$o_valid$/si ) {
  	    $arg =~ tr/_//d;
  	    $arg = ($type eq 'o' && $arg =~ /^0/) ? oct($arg) : 0+$arg;
  	}
  	else {
  	    if ( defined $optarg || $mand ) {
  		if ( $passthrough ) {
  		    unshift (@$argv, defined $rest ? $starter.$rest : $arg)
  		      unless defined $optarg;
  		    return (0);
  		}
  		warn ("Value \"", $arg, "\" invalid for option ",
  		      $opt, " (",
  		      $type eq 'o' ? "extended " : '',
  		      "number expected)\n");
  		$error++;
  		# Push back.
  		unshift (@$argv, $starter.$rest) if defined $rest;
  		return (1, undef);
  	    }
  	    else {
  		# Push back.
  		unshift (@$argv, defined $rest ? $starter.$rest : $arg);
  		if ( $type eq 'I' ) {
  		    # Fake incremental type.
  		    my @c = @$ctl;
  		    $c[CTL_TYPE] = '+';
  		    return (1, $opt, \@c, 1);
  		}
  		# Supply default value.
  		$arg = defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] : 0;
  	    }
  	}
      }
  
      elsif ( $type eq 'f' ) { # real number, int is also ok
  	# We require at least one digit before a point or 'e',
  	# and at least one digit following the point and 'e'.
  	# [-]NN[.NN][eNN]
  	my $o_valid = PAT_FLOAT;
  	if ( $bundling && defined $rest &&
  	     $rest =~ /^($key_valid)($o_valid)(.*)$/s ) {
  	    $arg =~ tr/_//d;
  	    ($key, $arg, $rest) = ($1, $2, $+);
  	    chop($key) if $key;
  	    unshift (@$argv, $starter.$rest) if defined $rest && $rest ne '';
  	}
  	elsif ( $arg =~ /^$o_valid$/ ) {
  	    $arg =~ tr/_//d;
  	}
  	else {
  	    if ( defined $optarg || $mand ) {
  		if ( $passthrough ) {
  		    unshift (@$argv, defined $rest ? $starter.$rest : $arg)
  		      unless defined $optarg;
  		    return (0);
  		}
  		warn ("Value \"", $arg, "\" invalid for option ",
  		      $opt, " (real number expected)\n");
  		$error++;
  		# Push back.
  		unshift (@$argv, $starter.$rest) if defined $rest;
  		return (1, undef);
  	    }
  	    else {
  		# Push back.
  		unshift (@$argv, defined $rest ? $starter.$rest : $arg);
  		# Supply default value.
  		$arg = 0.0;
  	    }
  	}
      }
      else {
  	die("Getopt::Long internal error (Can't happen)\n");
      }
      return (1, $opt, $ctl, $arg, $key);
  }
  
  sub ValidValue ($$$$$) {
      my ($ctl, $arg, $mand, $argend, $prefix) = @_;
  
      if ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
  	return 0 unless $arg =~ /[^=]+=(.*)/;
  	$arg = $1;
      }
  
      my $type = $ctl->[CTL_TYPE];
  
      if ( $type eq 's' ) {	# string
  	# A mandatory string takes anything.
  	return (1) if $mand;
  
  	return (1) if $arg eq "-";
  
  	# Check for option or option list terminator.
  	return 0 if $arg eq $argend || $arg =~ /^$prefix.+/;
  	return 1;
      }
  
      elsif ( $type eq 'i'	# numeric/integer
              || $type eq 'I'	# numeric/integer w/ incr default
  	    || $type eq 'o' ) { # dec/oct/hex/bin value
  
  	my $o_valid = $type eq 'o' ? PAT_XINT : PAT_INT;
  	return $arg =~ /^$o_valid$/si;
      }
  
      elsif ( $type eq 'f' ) { # real number, int is also ok
  	# We require at least one digit before a point or 'e',
  	# and at least one digit following the point and 'e'.
  	# [-]NN[.NN][eNN]
  	my $o_valid = PAT_FLOAT;
  	return $arg =~ /^$o_valid$/;
      }
      die("ValidValue: Cannot happen\n");
  }
  
  # Getopt::Long Configuration.
  sub Configure (@) {
      my (@options) = @_;
  
      my $prevconfig =
        [ $error, $debug, $major_version, $minor_version,
  	$autoabbrev, $getopt_compat, $ignorecase, $bundling, $order,
  	$gnu_compat, $passthrough, $genprefix, $auto_version, $auto_help,
  	$longprefix ];
  
      if ( ref($options[0]) eq 'ARRAY' ) {
  	( $error, $debug, $major_version, $minor_version,
  	  $autoabbrev, $getopt_compat, $ignorecase, $bundling, $order,
  	  $gnu_compat, $passthrough, $genprefix, $auto_version, $auto_help,
  	  $longprefix ) = @{shift(@options)};
      }
  
      my $opt;
      foreach $opt ( @options ) {
  	my $try = lc ($opt);
  	my $action = 1;
  	if ( $try =~ /^no_?(.*)$/s ) {
  	    $action = 0;
  	    $try = $+;
  	}
  	if ( ($try eq 'default' or $try eq 'defaults') && $action ) {
  	    ConfigDefaults ();
  	}
  	elsif ( ($try eq 'posix_default' or $try eq 'posix_defaults') ) {
  	    local $ENV{POSIXLY_CORRECT};
  	    $ENV{POSIXLY_CORRECT} = 1 if $action;
  	    ConfigDefaults ();
  	}
  	elsif ( $try eq 'auto_abbrev' or $try eq 'autoabbrev' ) {
  	    $autoabbrev = $action;
  	}
  	elsif ( $try eq 'getopt_compat' ) {
  	    $getopt_compat = $action;
              $genprefix = $action ? "(--|-|\\+)" : "(--|-)";
  	}
  	elsif ( $try eq 'gnu_getopt' ) {
  	    if ( $action ) {
  		$gnu_compat = 1;
  		$bundling = 1;
  		$getopt_compat = 0;
                  $genprefix = "(--|-)";
  		$order = $PERMUTE;
  	    }
  	}
  	elsif ( $try eq 'gnu_compat' ) {
  	    $gnu_compat = $action;
  	}
  	elsif ( $try =~ /^(auto_?)?version$/ ) {
  	    $auto_version = $action;
  	}
  	elsif ( $try =~ /^(auto_?)?help$/ ) {
  	    $auto_help = $action;
  	}
  	elsif ( $try eq 'ignorecase' or $try eq 'ignore_case' ) {
  	    $ignorecase = $action;
  	}
  	elsif ( $try eq 'ignorecase_always' or $try eq 'ignore_case_always' ) {
  	    $ignorecase = $action ? 2 : 0;
  	}
  	elsif ( $try eq 'bundling' ) {
  	    $bundling = $action;
  	}
  	elsif ( $try eq 'bundling_override' ) {
  	    $bundling = $action ? 2 : 0;
  	}
  	elsif ( $try eq 'require_order' ) {
  	    $order = $action ? $REQUIRE_ORDER : $PERMUTE;
  	}
  	elsif ( $try eq 'permute' ) {
  	    $order = $action ? $PERMUTE : $REQUIRE_ORDER;
  	}
  	elsif ( $try eq 'pass_through' or $try eq 'passthrough' ) {
  	    $passthrough = $action;
  	}
  	elsif ( $try =~ /^prefix=(.+)$/ && $action ) {
  	    $genprefix = $1;
  	    # Turn into regexp. Needs to be parenthesized!
  	    $genprefix = "(" . quotemeta($genprefix) . ")";
  	    eval { '' =~ /$genprefix/; };
  	    die("Getopt::Long: invalid pattern \"$genprefix\"") if $@;
  	}
  	elsif ( $try =~ /^prefix_pattern=(.+)$/ && $action ) {
  	    $genprefix = $1;
  	    # Parenthesize if needed.
  	    $genprefix = "(" . $genprefix . ")"
  	      unless $genprefix =~ /^\(.*\)$/;
  	    eval { '' =~ m"$genprefix"; };
  	    die("Getopt::Long: invalid pattern \"$genprefix\"") if $@;
  	}
  	elsif ( $try =~ /^long_prefix_pattern=(.+)$/ && $action ) {
  	    $longprefix = $1;
  	    # Parenthesize if needed.
  	    $longprefix = "(" . $longprefix . ")"
  	      unless $longprefix =~ /^\(.*\)$/;
  	    eval { '' =~ m"$longprefix"; };
  	    die("Getopt::Long: invalid long prefix pattern \"$longprefix\"") if $@;
  	}
  	elsif ( $try eq 'debug' ) {
  	    $debug = $action;
  	}
  	else {
  	    die("Getopt::Long: unknown config parameter \"$opt\"")
  	}
      }
      $prevconfig;
  }
  
  # Deprecated name.
  sub config (@) {
      Configure (@_);
  }
  
  # Issue a standard message for --version.
  #
  # The arguments are mostly the same as for Pod::Usage::pod2usage:
  #
  #  - a number (exit value)
  #  - a string (lead in message)
  #  - a hash with options. See Pod::Usage for details.
  #
  sub VersionMessage(@) {
      # Massage args.
      my $pa = setup_pa_args("version", @_);
  
      my $v = $main::VERSION;
      my $fh = $pa->{-output} ||
        ($pa->{-exitval} eq "NOEXIT" || $pa->{-exitval} < 2) ? \*STDOUT : \*STDERR;
  
      print $fh (defined($pa->{-message}) ? $pa->{-message} : (),
  	       $0, defined $v ? " version $v" : (),
  	       "\n",
  	       "(", __PACKAGE__, "::", "GetOptions",
  	       " version ",
  	       defined($Getopt::Long::VERSION_STRING)
  	         ? $Getopt::Long::VERSION_STRING : $VERSION, ";",
  	       " Perl version ",
  	       $] >= 5.006 ? sprintf("%vd", $^V) : $],
  	       ")\n");
      exit($pa->{-exitval}) unless $pa->{-exitval} eq "NOEXIT";
  }
  
  # Issue a standard message for --help.
  #
  # The arguments are the same as for Pod::Usage::pod2usage:
  #
  #  - a number (exit value)
  #  - a string (lead in message)
  #  - a hash with options. See Pod::Usage for details.
  #
  sub HelpMessage(@) {
      eval {
  	require Pod::Usage;
  	import Pod::Usage;
  	1;
      } || die("Cannot provide help: cannot load Pod::Usage\n");
  
      # Note that pod2usage will issue a warning if -exitval => NOEXIT.
      pod2usage(setup_pa_args("help", @_));
  
  }
  
  # Helper routine to set up a normalized hash ref to be used as
  # argument to pod2usage.
  sub setup_pa_args($@) {
      my $tag = shift;		# who's calling
  
      # If called by direct binding to an option, it will get the option
      # name and value as arguments. Remove these, if so.
      @_ = () if @_ == 2 && $_[0] eq $tag;
  
      my $pa;
      if ( @_ > 1 ) {
  	$pa = { @_ };
      }
      else {
  	$pa = shift || {};
      }
  
      # At this point, $pa can be a number (exit value), string
      # (message) or hash with options.
  
      if ( UNIVERSAL::isa($pa, 'HASH') ) {
  	# Get rid of -msg vs. -message ambiguity.
  	$pa->{-message} = $pa->{-msg};
  	delete($pa->{-msg});
      }
      elsif ( $pa =~ /^-?\d+$/ ) {
  	$pa = { -exitval => $pa };
      }
      else {
  	$pa = { -message => $pa };
      }
  
      # These are _our_ defaults.
      $pa->{-verbose} = 0 unless exists($pa->{-verbose});
      $pa->{-exitval} = 0 unless exists($pa->{-exitval});
      $pa;
  }
  
  # Sneak way to know what version the user requested.
  sub VERSION {
      $requested_version = $_[1];
      shift->SUPER::VERSION(@_);
  }
  
  package Getopt::Long::CallBack;
  
  sub new {
      my ($pkg, %atts) = @_;
      bless { %atts }, $pkg;
  }
  
  sub name {
      my $self = shift;
      ''.$self->{name};
  }
  
  use overload
    # Treat this object as an ordinary string for legacy API.
    '""'	   => \&name,
    fallback => 1;
  
  1;
  
  ################ Documentation ################
  
  =head1 NAME
  
  Getopt::Long - Extended processing of command line options
  
  =head1 SYNOPSIS
  
    use Getopt::Long;
    my $data   = "file.dat";
    my $length = 24;
    my $verbose;
    $result = GetOptions ("length=i" => \$length,    # numeric
                          "file=s"   => \$data,      # string
  			"verbose"  => \$verbose);  # flag
  
  =head1 DESCRIPTION
  
  The Getopt::Long module implements an extended getopt function called
  GetOptions(). This function adheres to the POSIX syntax for command
  line options, with GNU extensions. In general, this means that options
  have long names instead of single letters, and are introduced with a
  double dash "--". Support for bundling of command line options, as was
  the case with the more traditional single-letter approach, is provided
  but not enabled by default.
  
  =head1 Command Line Options, an Introduction
  
  Command line operated programs traditionally take their arguments from
  the command line, for example filenames or other information that the
  program needs to know. Besides arguments, these programs often take
  command line I<options> as well. Options are not necessary for the
  program to work, hence the name 'option', but are used to modify its
  default behaviour. For example, a program could do its job quietly,
  but with a suitable option it could provide verbose information about
  what it did.
  
  Command line options come in several flavours. Historically, they are
  preceded by a single dash C<->, and consist of a single letter.
  
      -l -a -c
  
  Usually, these single-character options can be bundled:
  
      -lac
  
  Options can have values, the value is placed after the option
  character. Sometimes with whitespace in between, sometimes not:
  
      -s 24 -s24
  
  Due to the very cryptic nature of these options, another style was
  developed that used long names. So instead of a cryptic C<-l> one
  could use the more descriptive C<--long>. To distinguish between a
  bundle of single-character options and a long one, two dashes are used
  to precede the option name. Early implementations of long options used
  a plus C<+> instead. Also, option values could be specified either
  like
  
      --size=24
  
  or
  
      --size 24
  
  The C<+> form is now obsolete and strongly deprecated.
  
  =head1 Getting Started with Getopt::Long
  
  Getopt::Long is the Perl5 successor of C<newgetopt.pl>. This was the
  first Perl module that provided support for handling the new style of
  command line options, hence the name Getopt::Long. This module also
  supports single-character options and bundling. Single character
  options may be any alphabetic character, a question mark, and a dash.
  Long options may consist of a series of letters, digits, and dashes.
  Although this is currently not enforced by Getopt::Long, multiple
  consecutive dashes are not allowed, and the option name must not end
  with a dash.
  
  To use Getopt::Long from a Perl program, you must include the
  following line in your Perl program:
  
      use Getopt::Long;
  
  This will load the core of the Getopt::Long module and prepare your
  program for using it. Most of the actual Getopt::Long code is not
  loaded until you really call one of its functions.
  
  In the default configuration, options names may be abbreviated to
  uniqueness, case does not matter, and a single dash is sufficient,
  even for long option names. Also, options may be placed between
  non-option arguments. See L<Configuring Getopt::Long> for more
  details on how to configure Getopt::Long.
  
  =head2 Simple options
  
  The most simple options are the ones that take no values. Their mere
  presence on the command line enables the option. Popular examples are:
  
      --all --verbose --quiet --debug
  
  Handling simple options is straightforward:
  
      my $verbose = '';	# option variable with default value (false)
      my $all = '';	# option variable with default value (false)
      GetOptions ('verbose' => \$verbose, 'all' => \$all);
  
  The call to GetOptions() parses the command line arguments that are
  present in C<@ARGV> and sets the option variable to the value C<1> if
  the option did occur on the command line. Otherwise, the option
  variable is not touched. Setting the option value to true is often
  called I<enabling> the option.
  
  The option name as specified to the GetOptions() function is called
  the option I<specification>. Later we'll see that this specification
  can contain more than just the option name. The reference to the
  variable is called the option I<destination>.
  
  GetOptions() will return a true value if the command line could be
  processed successfully. Otherwise, it will write error messages to
  STDERR, and return a false result.
  
  =head2 A little bit less simple options
  
  Getopt::Long supports two useful variants of simple options:
  I<negatable> options and I<incremental> options.
  
  A negatable option is specified with an exclamation mark C<!> after the
  option name:
  
      my $verbose = '';	# option variable with default value (false)
      GetOptions ('verbose!' => \$verbose);
  
  Now, using C<--verbose> on the command line will enable C<$verbose>,
  as expected. But it is also allowed to use C<--noverbose>, which will
  disable C<$verbose> by setting its value to C<0>. Using a suitable
  default value, the program can find out whether C<$verbose> is false
  by default, or disabled by using C<--noverbose>.
  
  An incremental option is specified with a plus C<+> after the
  option name:
  
      my $verbose = '';	# option variable with default value (false)
      GetOptions ('verbose+' => \$verbose);
  
  Using C<--verbose> on the command line will increment the value of
  C<$verbose>. This way the program can keep track of how many times the
  option occurred on the command line. For example, each occurrence of
  C<--verbose> could increase the verbosity level of the program.
  
  =head2 Mixing command line option with other arguments
  
  Usually programs take command line options as well as other arguments,
  for example, file names. It is good practice to always specify the
  options first, and the other arguments last. Getopt::Long will,
  however, allow the options and arguments to be mixed and 'filter out'
  all the options before passing the rest of the arguments to the
  program. To stop Getopt::Long from processing further arguments,
  insert a double dash C<--> on the command line:
  
      --size 24 -- --all
  
  In this example, C<--all> will I<not> be treated as an option, but
  passed to the program unharmed, in C<@ARGV>.
  
  =head2 Options with values
  
  For options that take values it must be specified whether the option
  value is required or not, and what kind of value the option expects.
  
  Three kinds of values are supported: integer numbers, floating point
  numbers, and strings.
  
  If the option value is required, Getopt::Long will take the
  command line argument that follows the option and assign this to the
  option variable. If, however, the option value is specified as
  optional, this will only be done if that value does not look like a
  valid command line option itself.
  
      my $tag = '';	# option variable with default value
      GetOptions ('tag=s' => \$tag);
  
  In the option specification, the option name is followed by an equals
  sign C<=> and the letter C<s>. The equals sign indicates that this
  option requires a value. The letter C<s> indicates that this value is
  an arbitrary string. Other possible value types are C<i> for integer
  values, and C<f> for floating point values. Using a colon C<:> instead
  of the equals sign indicates that the option value is optional. In
  this case, if no suitable value is supplied, string valued options get
  an empty string C<''> assigned, while numeric options are set to C<0>.
  
  =head2 Options with multiple values
  
  Options sometimes take several values. For example, a program could
  use multiple directories to search for library files:
  
      --library lib/stdlib --library lib/extlib
  
  To accomplish this behaviour, simply specify an array reference as the
  destination for the option:
  
      GetOptions ("library=s" => \@libfiles);
  
  Alternatively, you can specify that the option can have multiple
  values by adding a "@", and pass a scalar reference as the
  destination:
  
      GetOptions ("library=s@" => \$libfiles);
  
  Used with the example above, C<@libfiles> (or C<@$libfiles>) would
  contain two strings upon completion: C<"lib/srdlib"> and
  C<"lib/extlib">, in that order. It is also possible to specify that
  only integer or floating point numbers are acceptable values.
  
  Often it is useful to allow comma-separated lists of values as well as
  multiple occurrences of the options. This is easy using Perl's split()
  and join() operators:
  
      GetOptions ("library=s" => \@libfiles);
      @libfiles = split(/,/,join(',',@libfiles));
  
  Of course, it is important to choose the right separator string for
  each purpose.
  
  Warning: What follows is an experimental feature.
  
  Options can take multiple values at once, for example
  
      --coordinates 52.2 16.4 --rgbcolor 255 255 149
  
  This can be accomplished by adding a repeat specifier to the option
  specification. Repeat specifiers are very similar to the C<{...}>
  repeat specifiers that can be used with regular expression patterns.
  For example, the above command line would be handled as follows:
  
      GetOptions('coordinates=f{2}' => \@coor, 'rgbcolor=i{3}' => \@color);
  
  The destination for the option must be an array or array reference.
  
  It is also possible to specify the minimal and maximal number of
  arguments an option takes. C<foo=s{2,4}> indicates an option that
  takes at least two and at most 4 arguments. C<foo=s{,}> indicates one
  or more values; C<foo:s{,}> indicates zero or more option values.
  
  =head2 Options with hash values
  
  If the option destination is a reference to a hash, the option will
  take, as value, strings of the form I<key>C<=>I<value>. The value will
  be stored with the specified key in the hash.
  
      GetOptions ("define=s" => \%defines);
  
  Alternatively you can use:
  
      GetOptions ("define=s%" => \$defines);
  
  When used with command line options:
  
      --define os=linux --define vendor=redhat
  
  the hash C<%defines> (or C<%$defines>) will contain two keys, C<"os">
  with value C<"linux"> and C<"vendor"> with value C<"redhat">. It is
  also possible to specify that only integer or floating point numbers
  are acceptable values. The keys are always taken to be strings.
  
  =head2 User-defined subroutines to handle options
  
  Ultimate control over what should be done when (actually: each time)
  an option is encountered on the command line can be achieved by
  designating a reference to a subroutine (or an anonymous subroutine)
  as the option destination. When GetOptions() encounters the option, it
  will call the subroutine with two or three arguments. The first
  argument is the name of the option. (Actually, it is an object that
  stringifies to the name of the option.) For a scalar or array destination,
  the second argument is the value to be stored. For a hash destination,
  the second arguments is the key to the hash, and the third argument
  the value to be stored. It is up to the subroutine to store the value,
  or do whatever it thinks is appropriate.
  
  A trivial application of this mechanism is to implement options that
  are related to each other. For example:
  
      my $verbose = '';	# option variable with default value (false)
      GetOptions ('verbose' => \$verbose,
  	        'quiet'   => sub { $verbose = 0 });
  
  Here C<--verbose> and C<--quiet> control the same variable
  C<$verbose>, but with opposite values.
  
  If the subroutine needs to signal an error, it should call die() with
  the desired error message as its argument. GetOptions() will catch the
  die(), issue the error message, and record that an error result must
  be returned upon completion.
  
  If the text of the error message starts with an exclamation mark C<!>
  it is interpreted specially by GetOptions(). There is currently one
  special command implemented: C<die("!FINISH")> will cause GetOptions()
  to stop processing options, as if it encountered a double dash C<-->.
  
  In version 2.37 the first argument to the callback function was
  changed from string to object. This was done to make room for
  extensions and more detailed control. The object stringifies to the
  option name so this change should not introduce compatibility
  problems.
  
  =head2 Options with multiple names
  
  Often it is user friendly to supply alternate mnemonic names for
  options. For example C<--height> could be an alternate name for
  C<--length>. Alternate names can be included in the option
  specification, separated by vertical bar C<|> characters. To implement
  the above example:
  
      GetOptions ('length|height=f' => \$length);
  
  The first name is called the I<primary> name, the other names are
  called I<aliases>. When using a hash to store options, the key will
  always be the primary name.
  
  Multiple alternate names are possible.
  
  =head2 Case and abbreviations
  
  Without additional configuration, GetOptions() will ignore the case of
  option names, and allow the options to be abbreviated to uniqueness.
  
      GetOptions ('length|height=f' => \$length, "head" => \$head);
  
  This call will allow C<--l> and C<--L> for the length option, but
  requires a least C<--hea> and C<--hei> for the head and height options.
  
  =head2 Summary of Option Specifications
  
  Each option specifier consists of two parts: the name specification
  and the argument specification.
  
  The name specification contains the name of the option, optionally
  followed by a list of alternative names separated by vertical bar
  characters.
  
      length	      option name is "length"
      length|size|l     name is "length", aliases are "size" and "l"
  
  The argument specification is optional. If omitted, the option is
  considered boolean, a value of 1 will be assigned when the option is
  used on the command line.
  
  The argument specification can be
  
  =over 4
  
  =item !
  
  The option does not take an argument and may be negated by prefixing
  it with "no" or "no-". E.g. C<"foo!"> will allow C<--foo> (a value of
  1 will be assigned) as well as C<--nofoo> and C<--no-foo> (a value of
  0 will be assigned). If the option has aliases, this applies to the
  aliases as well.
  
  Using negation on a single letter option when bundling is in effect is
  pointless and will result in a warning.
  
  =item +
  
  The option does not take an argument and will be incremented by 1
  every time it appears on the command line. E.g. C<"more+">, when used
  with C<--more --more --more>, will increment the value three times,
  resulting in a value of 3 (provided it was 0 or undefined at first).
  
  The C<+> specifier is ignored if the option destination is not a scalar.
  
  =item = I<type> [ I<desttype> ] [ I<repeat> ]
  
  The option requires an argument of the given type. Supported types
  are:
  
  =over 4
  
  =item s
  
  String. An arbitrary sequence of characters. It is valid for the
  argument to start with C<-> or C<-->.
  
  =item i
  
  Integer. An optional leading plus or minus sign, followed by a
  sequence of digits.
  
  =item o
  
  Extended integer, Perl style. This can be either an optional leading
  plus or minus sign, followed by a sequence of digits, or an octal
  string (a zero, optionally followed by '0', '1', .. '7'), or a
  hexadecimal string (C<0x> followed by '0' .. '9', 'a' .. 'f', case
  insensitive), or a binary string (C<0b> followed by a series of '0'
  and '1').
  
  =item f
  
  Real number. For example C<3.14>, C<-6.23E24> and so on.
  
  =back
  
  The I<desttype> can be C<@> or C<%> to specify that the option is
  list or a hash valued. This is only needed when the destination for
  the option value is not otherwise specified. It should be omitted when
  not needed.
  
  The I<repeat> specifies the number of values this option takes per
  occurrence on the command line. It has the format C<{> [ I<min> ] [ C<,> [ I<max> ] ] C<}>.
  
  I<min> denotes the minimal number of arguments. It defaults to 1 for
  options with C<=> and to 0 for options with C<:>, see below. Note that
  I<min> overrules the C<=> / C<:> semantics.
  
  I<max> denotes the maximum number of arguments. It must be at least
  I<min>. If I<max> is omitted, I<but the comma is not>, there is no
  upper bound to the number of argument values taken.
  
  =item : I<type> [ I<desttype> ]
  
  Like C<=>, but designates the argument as optional.
  If omitted, an empty string will be assigned to string values options,
  and the value zero to numeric options.
  
  Note that if a string argument starts with C<-> or C<-->, it will be
  considered an option on itself.
  
  =item : I<number> [ I<desttype> ]
  
  Like C<:i>, but if the value is omitted, the I<number> will be assigned.
  
  =item : + [ I<desttype> ]
  
  Like C<:i>, but if the value is omitted, the current value for the
  option will be incremented.
  
  =back
  
  =head1 Advanced Possibilities
  
  =head2 Object oriented interface
  
  Getopt::Long can be used in an object oriented way as well:
  
      use Getopt::Long;
      $p = new Getopt::Long::Parser;
      $p->configure(...configuration options...);
      if ($p->getoptions(...options descriptions...)) ...
  
  Configuration options can be passed to the constructor:
  
      $p = new Getopt::Long::Parser
               config => [...configuration options...];
  
  =head2 Thread Safety
  
  Getopt::Long is thread safe when using ithreads as of Perl 5.8.  It is
  I<not> thread safe when using the older (experimental and now
  obsolete) threads implementation that was added to Perl 5.005.
  
  =head2 Documentation and help texts
  
  Getopt::Long encourages the use of Pod::Usage to produce help
  messages. For example:
  
      use Getopt::Long;
      use Pod::Usage;
  
      my $man = 0;
      my $help = 0;
  
      GetOptions('help|?' => \$help, man => \$man) or pod2usage(2);
      pod2usage(1) if $help;
      pod2usage(-exitstatus => 0, -verbose => 2) if $man;
  
      __END__
  
      =head1 NAME
  
      sample - Using Getopt::Long and Pod::Usage
  
      =head1 SYNOPSIS
  
      sample [options] [file ...]
  
       Options:
         -help            brief help message
         -man             full documentation
  
      =head1 OPTIONS
  
      =over 8
  
      =item B<-help>
  
      Print a brief help message and exits.
  
      =item B<-man>
  
      Prints the manual page and exits.
  
      =back
  
      =head1 DESCRIPTION
  
      B<This program> will read the given input file(s) and do something
      useful with the contents thereof.
  
      =cut
  
  See L<Pod::Usage> for details.
  
  =head2 Parsing options from an arbitrary array
  
  By default, GetOptions parses the options that are present in the
  global array C<@ARGV>. A special entry C<GetOptionsFromArray> can be
  used to parse options from an arbitrary array.
  
      use Getopt::Long qw(GetOptionsFromArray);
      $ret = GetOptionsFromArray(\@myopts, ...);
  
  When used like this, the global C<@ARGV> is not touched at all.
  
  The following two calls behave identically:
  
      $ret = GetOptions( ... );
      $ret = GetOptionsFromArray(\@ARGV, ... );
  
  =head2 Parsing options from an arbitrary string
  
  A special entry C<GetOptionsFromString> can be used to parse options
  from an arbitrary string.
  
      use Getopt::Long qw(GetOptionsFromString);
      $ret = GetOptionsFromString($string, ...);
  
  The contents of the string are split into arguments using a call to
  C<Text::ParseWords::shellwords>. As with C<GetOptionsFromArray>, the
  global C<@ARGV> is not touched.
  
  It is possible that, upon completion, not all arguments in the string
  have been processed. C<GetOptionsFromString> will, when called in list
  context, return both the return status and an array reference to any
  remaining arguments:
  
      ($ret, $args) = GetOptionsFromString($string, ... );
  
  If any arguments remain, and C<GetOptionsFromString> was not called in
  list context, a message will be given and C<GetOptionsFromString> will
  return failure.
  
  =head2 Storing options values in a hash
  
  Sometimes, for example when there are a lot of options, having a
  separate variable for each of them can be cumbersome. GetOptions()
  supports, as an alternative mechanism, storing options values in a
  hash.
  
  To obtain this, a reference to a hash must be passed I<as the first
  argument> to GetOptions(). For each option that is specified on the
  command line, the option value will be stored in the hash with the
  option name as key. Options that are not actually used on the command
  line will not be put in the hash, on other words,
  C<exists($h{option})> (or defined()) can be used to test if an option
  was used. The drawback is that warnings will be issued if the program
  runs under C<use strict> and uses C<$h{option}> without testing with
  exists() or defined() first.
  
      my %h = ();
      GetOptions (\%h, 'length=i');	# will store in $h{length}
  
  For options that take list or hash values, it is necessary to indicate
  this by appending an C<@> or C<%> sign after the type:
  
      GetOptions (\%h, 'colours=s@');	# will push to @{$h{colours}}
  
  To make things more complicated, the hash may contain references to
  the actual destinations, for example:
  
      my $len = 0;
      my %h = ('length' => \$len);
      GetOptions (\%h, 'length=i');	# will store in $len
  
  This example is fully equivalent with:
  
      my $len = 0;
      GetOptions ('length=i' => \$len);	# will store in $len
  
  Any mixture is possible. For example, the most frequently used options
  could be stored in variables while all other options get stored in the
  hash:
  
      my $verbose = 0;			# frequently referred
      my $debug = 0;			# frequently referred
      my %h = ('verbose' => \$verbose, 'debug' => \$debug);
      GetOptions (\%h, 'verbose', 'debug', 'filter', 'size=i');
      if ( $verbose ) { ... }
      if ( exists $h{filter} ) { ... option 'filter' was specified ... }
  
  =head2 Bundling
  
  With bundling it is possible to set several single-character options
  at once. For example if C<a>, C<v> and C<x> are all valid options,
  
      -vax
  
  would set all three.
  
  Getopt::Long supports two levels of bundling. To enable bundling, a
  call to Getopt::Long::Configure is required.
  
  The first level of bundling can be enabled with:
  
      Getopt::Long::Configure ("bundling");
  
  Configured this way, single-character options can be bundled but long
  options B<must> always start with a double dash C<--> to avoid
  ambiguity. For example, when C<vax>, C<a>, C<v> and C<x> are all valid
  options,
  
      -vax
  
  would set C<a>, C<v> and C<x>, but
  
      --vax
  
  would set C<vax>.
  
  The second level of bundling lifts this restriction. It can be enabled
  with:
  
      Getopt::Long::Configure ("bundling_override");
  
  Now, C<-vax> would set the option C<vax>.
  
  When any level of bundling is enabled, option values may be inserted
  in the bundle. For example:
  
      -h24w80
  
  is equivalent to
  
      -h 24 -w 80
  
  When configured for bundling, single-character options are matched
  case sensitive while long options are matched case insensitive. To
  have the single-character options matched case insensitive as well,
  use:
  
      Getopt::Long::Configure ("bundling", "ignorecase_always");
  
  It goes without saying that bundling can be quite confusing.
  
  =head2 The lonesome dash
  
  Normally, a lone dash C<-> on the command line will not be considered
  an option. Option processing will terminate (unless "permute" is
  configured) and the dash will be left in C<@ARGV>.
  
  It is possible to get special treatment for a lone dash. This can be
  achieved by adding an option specification with an empty name, for
  example:
  
      GetOptions ('' => \$stdio);
  
  A lone dash on the command line will now be a legal option, and using
  it will set variable C<$stdio>.
  
  =head2 Argument callback
  
  A special option 'name' C<< <> >> can be used to designate a subroutine
  to handle non-option arguments. When GetOptions() encounters an
  argument that does not look like an option, it will immediately call this
  subroutine and passes it one parameter: the argument name. Well, actually
  it is an object that stringifies to the argument name.
  
  For example:
  
      my $width = 80;
      sub process { ... }
      GetOptions ('width=i' => \$width, '<>' => \&process);
  
  When applied to the following command line:
  
      arg1 --width=72 arg2 --width=60 arg3
  
  This will call
  C<process("arg1")> while C<$width> is C<80>,
  C<process("arg2")> while C<$width> is C<72>, and
  C<process("arg3")> while C<$width> is C<60>.
  
  This feature requires configuration option B<permute>, see section
  L<Configuring Getopt::Long>.
  
  =head1 Configuring Getopt::Long
  
  Getopt::Long can be configured by calling subroutine
  Getopt::Long::Configure(). This subroutine takes a list of quoted
  strings, each specifying a configuration option to be enabled, e.g.
  C<ignore_case>, or disabled, e.g. C<no_ignore_case>. Case does not
  matter. Multiple calls to Configure() are possible.
  
  Alternatively, as of version 2.24, the configuration options may be
  passed together with the C<use> statement:
  
      use Getopt::Long qw(:config no_ignore_case bundling);
  
  The following options are available:
  
  =over 12
  
  =item default
  
  This option causes all configuration options to be reset to their
  default values.
  
  =item posix_default
  
  This option causes all configuration options to be reset to their
  default values as if the environment variable POSIXLY_CORRECT had
  been set.
  
  =item auto_abbrev
  
  Allow option names to be abbreviated to uniqueness.
  Default is enabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<auto_abbrev> is disabled.
  
  =item getopt_compat
  
  Allow C<+> to start options.
  Default is enabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<getopt_compat> is disabled.
  
  =item gnu_compat
  
  C<gnu_compat> controls whether C<--opt=> is allowed, and what it should
  do. Without C<gnu_compat>, C<--opt=> gives an error. With C<gnu_compat>,
  C<--opt=> will give option C<opt> and empty value.
  This is the way GNU getopt_long() does it.
  
  =item gnu_getopt
  
  This is a short way of setting C<gnu_compat> C<bundling> C<permute>
  C<no_getopt_compat>. With C<gnu_getopt>, command line handling should be
  fully compatible with GNU getopt_long().
  
  =item require_order
  
  Whether command line arguments are allowed to be mixed with options.
  Default is disabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<require_order> is enabled.
  
  See also C<permute>, which is the opposite of C<require_order>.
  
  =item permute
  
  Whether command line arguments are allowed to be mixed with options.
  Default is enabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<permute> is disabled.
  Note that C<permute> is the opposite of C<require_order>.
  
  If C<permute> is enabled, this means that
  
      --foo arg1 --bar arg2 arg3
  
  is equivalent to
  
      --foo --bar arg1 arg2 arg3
  
  If an argument callback routine is specified, C<@ARGV> will always be
  empty upon successful return of GetOptions() since all options have been
  processed. The only exception is when C<--> is used:
  
      --foo arg1 --bar arg2 -- arg3
  
  This will call the callback routine for arg1 and arg2, and then
  terminate GetOptions() leaving C<"arg3"> in C<@ARGV>.
  
  If C<require_order> is enabled, options processing
  terminates when the first non-option is encountered.
  
      --foo arg1 --bar arg2 arg3
  
  is equivalent to
  
      --foo -- arg1 --bar arg2 arg3
  
  If C<pass_through> is also enabled, options processing will terminate
  at the first unrecognized option, or non-option, whichever comes
  first.
  
  =item bundling (default: disabled)
  
  Enabling this option will allow single-character options to be
  bundled. To distinguish bundles from long option names, long options
  I<must> be introduced with C<--> and bundles with C<->.
  
  Note that, if you have options C<a>, C<l> and C<all>, and
  auto_abbrev enabled, possible arguments and option settings are:
  
      using argument               sets option(s)
      ------------------------------------------
      -a, --a                      a
      -l, --l                      l
      -al, -la, -ala, -all,...     a, l
      --al, --all                  all
  
  The surprising part is that C<--a> sets option C<a> (due to auto
  completion), not C<all>.
  
  Note: disabling C<bundling> also disables C<bundling_override>.
  
  =item bundling_override (default: disabled)
  
  If C<bundling_override> is enabled, bundling is enabled as with
  C<bundling> but now long option names override option bundles.
  
  Note: disabling C<bundling_override> also disables C<bundling>.
  
  B<Note:> Using option bundling can easily lead to unexpected results,
  especially when mixing long options and bundles. Caveat emptor.
  
  =item ignore_case  (default: enabled)
  
  If enabled, case is ignored when matching long option names. If,
  however, bundling is enabled as well, single character options will be
  treated case-sensitive.
  
  With C<ignore_case>, option specifications for options that only
  differ in case, e.g., C<"foo"> and C<"Foo">, will be flagged as
  duplicates.
  
  Note: disabling C<ignore_case> also disables C<ignore_case_always>.
  
  =item ignore_case_always (default: disabled)
  
  When bundling is in effect, case is ignored on single-character
  options also.
  
  Note: disabling C<ignore_case_always> also disables C<ignore_case>.
  
  =item auto_version (default:disabled)
  
  Automatically provide support for the B<--version> option if
  the application did not specify a handler for this option itself.
  
  Getopt::Long will provide a standard version message that includes the
  program name, its version (if $main::VERSION is defined), and the
  versions of Getopt::Long and Perl. The message will be written to
  standard output and processing will terminate.
  
  C<auto_version> will be enabled if the calling program explicitly
  specified a version number higher than 2.32 in the C<use> or
  C<require> statement.
  
  =item auto_help (default:disabled)
  
  Automatically provide support for the B<--help> and B<-?> options if
  the application did not specify a handler for this option itself.
  
  Getopt::Long will provide a help message using module L<Pod::Usage>. The
  message, derived from the SYNOPSIS POD section, will be written to
  standard output and processing will terminate.
  
  C<auto_help> will be enabled if the calling program explicitly
  specified a version number higher than 2.32 in the C<use> or
  C<require> statement.
  
  =item pass_through (default: disabled)
  
  Options that are unknown, ambiguous or supplied with an invalid option
  value are passed through in C<@ARGV> instead of being flagged as
  errors. This makes it possible to write wrapper scripts that process
  only part of the user supplied command line arguments, and pass the
  remaining options to some other program.
  
  If C<require_order> is enabled, options processing will terminate at
  the first unrecognized option, or non-option, whichever comes first.
  However, if C<permute> is enabled instead, results can become confusing.
  
  Note that the options terminator (default C<-->), if present, will
  also be passed through in C<@ARGV>.
  
  =item prefix
  
  The string that starts options. If a constant string is not
  sufficient, see C<prefix_pattern>.
  
  =item prefix_pattern
  
  A Perl pattern that identifies the strings that introduce options.
  Default is C<--|-|\+> unless environment variable
  POSIXLY_CORRECT has been set, in which case it is C<--|->.
  
  =item long_prefix_pattern
  
  A Perl pattern that allows the disambiguation of long and short
  prefixes. Default is C<-->.
  
  Typically you only need to set this if you are using nonstandard
  prefixes and want some or all of them to have the same semantics as
  '--' does under normal circumstances.
  
  For example, setting prefix_pattern to C<--|-|\+|\/> and
  long_prefix_pattern to C<--|\/> would add Win32 style argument
  handling.
  
  =item debug (default: disabled)
  
  Enable debugging output.
  
  =back
  
  =head1 Exportable Methods
  
  =over
  
  =item VersionMessage
  
  This subroutine provides a standard version message. Its argument can be:
  
  =over 4
  
  =item *
  
  A string containing the text of a message to print I<before> printing
  the standard message.
  
  =item *
  
  A numeric value corresponding to the desired exit status.
  
  =item *
  
  A reference to a hash.
  
  =back
  
  If more than one argument is given then the entire argument list is
  assumed to be a hash.  If a hash is supplied (either as a reference or
  as a list) it should contain one or more elements with the following
  keys:
  
  =over 4
  
  =item C<-message>
  
  =item C<-msg>
  
  The text of a message to print immediately prior to printing the
  program's usage message.
  
  =item C<-exitval>
  
  The desired exit status to pass to the B<exit()> function.
  This should be an integer, or else the string "NOEXIT" to
  indicate that control should simply be returned without
  terminating the invoking process.
  
  =item C<-output>
  
  A reference to a filehandle, or the pathname of a file to which the
  usage message should be written. The default is C<\*STDERR> unless the
  exit value is less than 2 (in which case the default is C<\*STDOUT>).
  
  =back
  
  You cannot tie this routine directly to an option, e.g.:
  
      GetOptions("version" => \&VersionMessage);
  
  Use this instead:
  
      GetOptions("version" => sub { VersionMessage() });
  
  =item HelpMessage
  
  This subroutine produces a standard help message, derived from the
  program's POD section SYNOPSIS using L<Pod::Usage>. It takes the same
  arguments as VersionMessage(). In particular, you cannot tie it
  directly to an option, e.g.:
  
      GetOptions("help" => \&HelpMessage);
  
  Use this instead:
  
      GetOptions("help" => sub { HelpMessage() });
  
  =back
  
  =head1 Return values and Errors
  
  Configuration errors and errors in the option definitions are
  signalled using die() and will terminate the calling program unless
  the call to Getopt::Long::GetOptions() was embedded in C<eval { ...
  }>, or die() was trapped using C<$SIG{__DIE__}>.
  
  GetOptions returns true to indicate success.
  It returns false when the function detected one or more errors during
  option parsing. These errors are signalled using warn() and can be
  trapped with C<$SIG{__WARN__}>.
  
  =head1 Legacy
  
  The earliest development of C<newgetopt.pl> started in 1990, with Perl
  version 4. As a result, its development, and the development of
  Getopt::Long, has gone through several stages. Since backward
  compatibility has always been extremely important, the current version
  of Getopt::Long still supports a lot of constructs that nowadays are
  no longer necessary or otherwise unwanted. This section describes
  briefly some of these 'features'.
  
  =head2 Default destinations
  
  When no destination is specified for an option, GetOptions will store
  the resultant value in a global variable named C<opt_>I<XXX>, where
  I<XXX> is the primary name of this option. When a progam executes
  under C<use strict> (recommended), these variables must be
  pre-declared with our() or C<use vars>.
  
      our $opt_length = 0;
      GetOptions ('length=i');	# will store in $opt_length
  
  To yield a usable Perl variable, characters that are not part of the
  syntax for variables are translated to underscores. For example,
  C<--fpp-struct-return> will set the variable
  C<$opt_fpp_struct_return>. Note that this variable resides in the
  namespace of the calling program, not necessarily C<main>. For
  example:
  
      GetOptions ("size=i", "sizes=i@");
  
  with command line "-size 10 -sizes 24 -sizes 48" will perform the
  equivalent of the assignments
  
      $opt_size = 10;
      @opt_sizes = (24, 48);
  
  =head2 Alternative option starters
  
  A string of alternative option starter characters may be passed as the
  first argument (or the first argument after a leading hash reference
  argument).
  
      my $len = 0;
      GetOptions ('/', 'length=i' => $len);
  
  Now the command line may look like:
  
      /length 24 -- arg
  
  Note that to terminate options processing still requires a double dash
  C<-->.
  
  GetOptions() will not interpret a leading C<< "<>" >> as option starters
  if the next argument is a reference. To force C<< "<" >> and C<< ">" >> as
  option starters, use C<< "><" >>. Confusing? Well, B<using a starter
  argument is strongly deprecated> anyway.
  
  =head2 Configuration variables
  
  Previous versions of Getopt::Long used variables for the purpose of
  configuring. Although manipulating these variables still work, it is
  strongly encouraged to use the C<Configure> routine that was introduced
  in version 2.17. Besides, it is much easier.
  
  =head1 Tips and Techniques
  
  =head2 Pushing multiple values in a hash option
  
  Sometimes you want to combine the best of hashes and arrays. For
  example, the command line:
  
    --list add=first --list add=second --list add=third
  
  where each successive 'list add' option will push the value of add
  into array ref $list->{'add'}. The result would be like
  
    $list->{add} = [qw(first second third)];
  
  This can be accomplished with a destination routine:
  
    GetOptions('list=s%' =>
                 sub { push(@{$list{$_[1]}}, $_[2]) });
  
  =head1 Troubleshooting
  
  =head2 GetOptions does not return a false result when an option is not supplied
  
  That's why they're called 'options'.
  
  =head2 GetOptions does not split the command line correctly
  
  The command line is not split by GetOptions, but by the command line
  interpreter (CLI). On Unix, this is the shell. On Windows, it is
  COMMAND.COM or CMD.EXE. Other operating systems have other CLIs.
  
  It is important to know that these CLIs may behave different when the
  command line contains special characters, in particular quotes or
  backslashes. For example, with Unix shells you can use single quotes
  (C<'>) and double quotes (C<">) to group words together. The following
  alternatives are equivalent on Unix:
  
      "two words"
      'two words'
      two\ words
  
  In case of doubt, insert the following statement in front of your Perl
  program:
  
      print STDERR (join("|",@ARGV),"\n");
  
  to verify how your CLI passes the arguments to the program.
  
  =head2 Undefined subroutine &main::GetOptions called
  
  Are you running Windows, and did you write
  
      use GetOpt::Long;
  
  (note the capital 'O')?
  
  =head2 How do I put a "-?" option into a Getopt::Long?
  
  You can only obtain this using an alias, and Getopt::Long of at least
  version 2.13.
  
      use Getopt::Long;
      GetOptions ("help|?");    # -help and -? will both set $opt_help
  
  =head1 AUTHOR
  
  Johan Vromans <jvromans@squirrel.nl>
  
  =head1 COPYRIGHT AND DISCLAIMER
  
  This program is Copyright 1990,2009 by Johan Vromans.
  This program is free software; you can redistribute it and/or
  modify it under the terms of the Perl Artistic License or the
  GNU General Public License as published by the Free Software
  Foundation; either version 2 of the License, or (at your option) any
  later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  
  If you do not have a copy of the GNU General Public License write to
  the Free Software Foundation, Inc., 675 Mass Ave, Cambridge,
  MA 02139, USA.
  
  =cut
  
GETOPT_LONG

$fatpacked{"Text/Aligner.pm"} = <<'TEXT_ALIGNER';
  # Text::Aligner - Align text in columns
  package Text::Aligner;
  use strict;
  use warnings;
  
  BEGIN    {
      use Exporter ();
      use vars qw ($VERSION @ISA @EXPORT @EXPORT_OK %EXPORT_TAGS);
      $VERSION     = '0.07';
      @ISA         = qw (Exporter);
      @EXPORT      = qw ();
      @EXPORT_OK   = qw ( align);
      %EXPORT_TAGS = ();
  }
  
  # this is a non-method, and currently the only user interface
  sub align ($@) {
      my $ali = Text::Aligner->new( shift);
      $ali->alloc( map ref eq 'SCALAR' ? $$_ : $_, @_);
      if ( defined wantarray ) {
          my @just = map $ali->justify( ref eq 'SCALAR' ? $$_ : $_), @_;
          return @just if wantarray;
          return join "\n", @just, '';
      } else {
          for ( @_ ) {
              $_ = $ali->justify( $_) for ref eq 'SCALAR' ? $$_ : $_; # one-shot
          }
      }
  }
  
  ### class Text::Aligner
  
  sub _new { # internal creator
      my $class = shift;
      my ( $width, $pos) = @_; # both method-or-coderef (this is very general)
      bless {
          width => $width,
          pos => $pos,
          left => Text::Aligner::MaxKeeper->new,
          right => Text::Aligner::MaxKeeper->new,
      }, $class;
  }
  
  # create an aligner
  sub new {
      my ( $class, $spec) = @_;
      $spec ||= 0; # left alignment is default
      my $al;
      if ( !ref( $spec) and $spec =~ s/^auto/num/ ) {
          $al = Text::Aligner::Auto->_new( $spec);
      } else {
          $al = $class->_new( _compile_alispec( $spec));
      }
      $al;
  }
  
  # return left and right field widths for an object
  sub _measure0 {
      my $al = shift;
      my $obj = shift;
      $obj = '' unless defined $obj;
      my ( $w, $p);
      if ( ref $obj ) {
          ( $w, $p) = ( $obj->$al->{ width}->(), $obj->$al->{ pos}->() );
      } else {
          ( $w, $p) = ( $al->{ width}->( $obj), $al->{ pos}->( $obj) );
      }
      $_ ||= 0 for $w, $p;
      ( $p, $w - $p);
  }
  
  use Term::ANSIColor;
  *colorstrip = \ &Term::ANSIColor::colorstrip;
  # early versions of Term::ANSIColor don't have colorstrip
  defined &colorstrip or *colorstrip = sub { shift };
  
  # return left and right field widths for an object
  sub _measure {
      my $al = shift;
      my $obj = shift;
      $obj = '' unless defined $obj;
      my ( $wmeth, $pmeth) = @{ $al}{ qw( width pos)};
  
      # support colorized strings
      $obj = colorstrip($obj) unless ref $obj;
  
      my $w = ref $wmeth ? $wmeth->( $obj) : $obj->$wmeth;
      my $p = ref $pmeth ? $pmeth->( $obj) : $obj->$pmeth;
      $_ ||= 0 for $w, $p;
      ( $p, $w - $p);
  }
  
  # return left and rigth maxima, or nothing if the aligner is empty
  sub _status {
      my @lr = ( $_[ 0]->{ left}->max, $_[ 0]->{ right}->max);
      # $l and $r should be both defined or undefined, unless the
      # MaxKeeper memory is corrupted by forgetting unremembered things.
      return unless defined( $lr[ 0]) and defined( $lr[ 1]);
      @lr;
  }
  
  # remember alignment requirements
  sub alloc {
      my $al = shift;
      for ( @_ ) {
  #       $_ ||= ''; print "allocing '$_'\n";
          my ( $l, $r) = $al->_measure( $_);
          $al->{ left}->remember( $l); # space needed left of pos
          $al->{ right}->remember( $r); # ...and right of pos
      }
      $al;
  }
  
  # release alignment requirement.  it disturbs an aligner deeply to forget
  # things it hasn't remembered.  the effects may be delayed.
  sub _forget {
      my $al = shift;
      for ( map defined() ? $_ : '', @_ ) {
  #       print "forgetting '$_'\n";
          my ( $l, $r) = $al->_measure( $_);
          $al->{ left}->forget( $l);
          $al->{ right}->forget( $r);
      }
      $al;
  }
  
  # justify a string.  a string is aligned within the aligner's field, and
  # filled with blanks or cut to size, as appropriate.  a string that has
  # been allocated will never be trimmed (that is the point of allocation).
  # if the aligner is empty it returns the string unaltered.
  sub justify {
      my $al = shift;
      my $str  = shift;
  #   print "justifying '$str'\n";
      $str .= ''; # stringify (objects, numbers, undef)
      my ( $l_pad, $r_pad) = $al->_padding( $str);
      substr( $str, 0, -$l_pad) = '' if $l_pad < 0; # trim if negative
      substr( $str, $r_pad) = '' if $r_pad < 0; # ... both ends
      join $str, ' ' x $l_pad, ' ' x $r_pad; # pad if positive
  }
  
  # return two numbers that indicate how many blanks are needed on each side
  # of a string to justify it.  Negative values mean trim that many characters.
  # an empty aligner returns ( 0, 0), so doesn't change anything.
  sub _padding {
      my $al = shift;
      my $str = shift;
      my ( $this_l, $this_r) = $al->_measure( $str);
      my ( $l_pad, $r_pad) = ( 0, 0);
      if ( $al->_status ) {
          ( $l_pad, $r_pad) = $al->_status;
          $l_pad -= $this_l;
          $r_pad -= $this_r;
      }
      ( $l_pad, $r_pad);
  }
  
  # _compile_alispec() returns positioners according to specification.  In
  # effect, it is is the interpreter for alignment specifications.
  
  sub _compile_alispec { # it's a dirty job...
      my $width = sub { length shift }; # this is always so for string aligners
      my $pos; # the positioner we actually compile
      local $_ = shift || ''; # alignment specification
      if ( ref() eq 'Regexp' ) { 
          my $regex = $_; # lexical copy!
          $pos = sub {
              local $_ = shift;
              return m/$regex/ ? $-[ 0] : length; # assume match after string
          };
      } else {
          s/^left/0/;
          s/^center/0.5/;
          s/^right/1/;
          if ( _is_number( $_) ) {
              my $proportion = $_; # use lexical copy
              $pos = sub { int( $proportion*length shift) };
          } elsif ( $_ =~ /^(?:num|point)(?:\((.*))?/ ) {
              my $point = defined $1 ? $1 : '';
              $point =~ s/\)$//; # ignore trailing paren, if present
              length $point or $point = '.';
              $pos = sub { index( shift() . $point, $point) }
          } else {
              $pos = sub { 0 };
          }
      }
      ( $width, $pos);
  }
  
  # decide if a string is a number. (see perlfaq4).
  sub _is_number {
      my ($x) = @_;
      return 0 unless defined $x;
      return 0 if $x !~ /\d/;
      return 1 if $x =~ /^-?\d+\.?\d*$/;
      $x = colorstrip($x);
      $x =~ /^-?\d+\.?\d*$/
  }
  
  package Text::Aligner::Auto;
  # Combined numeric and left alignment.  Numbers are aligned numerically,
  # other strings are left-aligned.  The resulting columns are interleaved
  # flush left and filled on the right if necessary.
  
  sub _new { # only called by Text::Aligner->new()
      my $class = shift;
      my $numspec = shift; # currently ignored
      bless {
          num => Text::Aligner->new( 'num'),    # align numbers among themselves
          other => Text::Aligner->new,          # left-align anything else
      }, $class;
  }
  
  sub alloc {
      my $aa = shift;
      my @num = grep _is_number( $_), @_;
      my @other = grep !_is_number( $_), @_;
      $aa->{ num}->alloc( @num);
      $aa->{ other}->alloc( @other);
      $aa;
  }
  
  sub _forget {
      my $aa = shift;
      $aa->{ num}->_forget( grep _is_number( $_), @_);
      $aa->{ other}->_forget( grep !_is_number( $_), @_);
      $aa;
  }
  
  # justify as required
  sub justify {
      my ( $aa, $str) = @_;
      # align according to type
      $str = $aa->{ _is_number( $str) ? 'num' : 'other'}->justify( $str);
      my $combi = Text::Aligner->new; # left-justify pre-aligned string
      # initialise to size of partial aligners.  (don't initialise from
      # empty aligner)
      $combi->alloc( $aa->{ num}->justify( '')) if $aa->{ num}->_status;
      $combi->alloc( $aa->{ other}->justify( '')) if $aa->{ other}->_status;
      $combi->justify( $str);
  }
  
  # for convenience
  BEGIN { # import _is_number()
      *_is_number = \ &Text::Aligner::_is_number;
  }
  
  package Text::Aligner::MaxKeeper;
  # Keep the maximum of a dynamic set of numbers.  Optimized for the case of
  # a relatively small range of numbers that may occur repeatedly.
  
  sub new {
      bless {
          max => undef,
          seen => {},
      }, shift;
  }
  
  sub max { $_[ 0]->{ max} }
  
  sub remember {
      my ( $mk, $val) = @_;
      _to_max( $mk->{ max}, $val);
      $mk->{ seen}->{ $val}++;
      $mk;
  }
  
  sub forget {
      my ( $mk, $val) = @_;
      if ( exists $mk->{ seen}->{ $val} ) {
          my $seen = $mk->{ seen};
          unless ( --$seen->{ $val} ) {
              delete $seen->{ $val};
              if ( $mk->{ max} == $val ) {
                  # lost the maximum, recalculate
                  undef $mk->{ max};
                  _to_max( $mk->{ max}, keys %$seen);
              }
          }
      }
      $mk;
  }
  
  sub _to_max {
      my $var = \ shift;
      defined $_ and ( not defined $$var or $$var < $_) and $$var = $_ for @_;
      $$var;
  }
  
  ########################################### main pod documentation begin ##
  
  =head1 NAME
  
  Text::Aligner
  
  =head1 SYNOPSIS
  
    use Text::Aligner qw( align);
  
    # Print the words "just a test!" right-justified each on a line:
  
    my @lines = align( 'right', qw( just a test!);
    print "$_\n" for @lines;
  
  =head1 DESCRIPTION
  
  Text::Aligner exports a single function, align(), which is
  used to justify strings to various alignment styles.  The
  alignment specification is the first argument, followed by
  any number of scalars which are subject to alignment.
  
  The operation depends on context.  In list context, a list of
  the justified scalars is returned.  In scalar context, the
  justified arguments are joined into a single string with newlines
  appended.  The original arguments remain unchanged.  In void
  context, in-place justification is attempted.  In this case, all
  arguments must be lvalues.
  
  Align() also does one level of scalar dereferencing.  That is,
  whenever one of the arguments is a scalar reference, the scalar
  pointed to is aligned instead.  Other references are simply stringified.
  An undefined argument is interpreted as an empty string without
  complaint.
  
  Alignment respects colorizing escape sequences a la Term::ANSICOLOR,
  which means it knows that thses sequences don't take up space on
  the screen.
  
  =head1 ALIGNMENT
  
  The first argument of the align() function is an alignment style, a
  single scalar.
  
  It can be one of the strings "left", "right", "center", "num", "point",
  or "auto", or a regular expression (qr/.../), or a coderef.
  
  A default style of "left" is assumed for every other value, including
  "" and undef. 
  
  "left", "right" and "center" have the obvious meanings.  These can
  also be given as numbers 0, 1, and 0.5 respectively. (Other numbers
  are also possible, but probably not very useful).
  
  "num", and its synonym "point", specify that the decimal points be
  aligned (assumed on the right, unless present).  Arbitrary (non-numeric)
  strings are also aligned in this manner, so they end up one column left
  of the (possibly assumed) decimal point, flush right with any integers. 
  For the occasional string like "inf", or "-" for missing values, this
  may be the right place.  A string-only column ends up right-aligned
  (unless there are points present).
  
  The "auto" style separates numeric strings (that are composed of
  "-", ".", and digits in the usual manner) and aligns them numerically.
  Other strings are left aligned with the number that sticks out
  farthest to the left.  This gives left alignment for string-only
  columns and numeric alignment for columns of numbers.  In mixed
  columns, strings are reasonably placed to serve as column headings
  or intermediate titles.
  
  With "num" (and "point") it is possible to specify another character
  for the decimal point in the form "num(,)".  In fact, you can specify
  any string after a leading "(", and the closing ")" is optional.
  "point(=>)" could be used to align certain pieces of Perl code.  This
  option is currently not available with "auto" alignment (because
  recognition of numbers is Anglo-centric).
  
  If a regular expression is specified, the points are aligned where
  the first match of the regex starts.  A match is assumed immediately
  after the string if it doesn't match.
  
  A regular expression is a powerful way of alignment specification.  It
  can replace most others easily, except center alignment and, of course,
  the double action of "auto".
  
  =head1 POSITIONERS
  
  For entirely self-defined forms of alignment, a coderef, also known
  as a positioner, can be given instead of an alignment style.  This
  code will be called once or more times with the string to be aligned
  as its argument.  It must return two numbers, a width and a position,
  that describe how to align a string with other strings.
  
  The width should normally be the length of the string.  The position
  defines a point relative to the beginning of the string, which is
  aligned with the positions given for other strings.
  
  A zero position for all strings results in left alignment, positioning
  to the end of the string results in right alignment, and returning
  half the length gives center alignment.  "num" alignment is realized
  by marking the position of the decimal point.
  
  Note that the position you return is a relative measure.  Adding a
  constant value to all positions results in no change in alignment.
  It doesn't have to point inside the string (as in right alignment,
  where it points one character past the end of the string).
  
  The first return value of a positioner should almost always be the
  length of the given string.  It may be useful to ly about the string
  length if the string contains escape sequences that occupy no place
  on screen.
  
  =head1 USAGE
  
    use Text::Aligner qw( align);
  
    align( $style, $str, ...);
  
    $style must be given and must be an alignment specification.
    Any number of scalars can follow.  An argument that contains a
    scalar reference is dereferenced before it is used.  In scalar
    and list context, the aligned strings are returned.  In void
    context, the values are aligned in place and must be lvalues.
  
  =head1 BUGS
  
    None known as of realease, but...
  
  =head1 AUTHOR
  
      Anno Siegel
      CPAN ID: ANNO
  
  =head1 COPYRIGHT
  
  Copyright (c) 2002 Anno Siegel. All rights reserved.
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =head1 SEE ALSO
  
  perl(1)
  
  Text::Table
  
  =cut
  
  1; #this line is important and will help the module return a true value
  __END__
TEXT_ALIGNER

$fatpacked{"Text/Table.pm"} = <<'TEXT_TABLE';
  # Text::Table - Organize Data in Tables
  package Text::Table;
  
  use strict;
  use warnings;
  
  use List::Util qw(sum max);
  
  use Text::Aligner qw(align);
  
  BEGIN {
      our $VERSION = '1.124';
  }
  
  use overload
      '""'  => 'stringify',
  ;
  
  ### User interface:  How to specify columns and column separators
  
  sub _is_sep {
      my $datum = shift;
  
      return 
      (
          defined($datum) 
              and
          (
              (ref($datum) eq 'SCALAR')
                      or
              (ref($datum) eq 'HASH' and $datum->{is_sep})
          )
      );
  }
  
  sub _get_sep_title_body
  {
      my $sep = shift;
  
      return
          +( ref($sep) eq 'HASH' )
          ? @{ $sep }{qw(title body)}
          : split( /\n/, ${$sep}, -1 ) ;
  }
  
  sub _parse_sep {
      my $sep = shift;
  
      if (!defined($sep))
      {
          $sep = '';
      }
  
      my ($title, $body) = _get_sep_title_body($sep);
  
      if (!defined($body))
      {
          $body = $title;
      }
  
      ($title, $body) = align( 'left', $title, $body);
  
      return
      {
          is_sep => 1,
          title  => $title,
          body   => $body,
      };
  }
  
  sub _default_if_empty
  {
      my ($ref, $default) = @_;
  
      if (! (defined($$ref) && length($$ref)))
      {
          $$ref = $default;
      }
  
      return;
  }
  
  sub _is_align
  {
      my $align = shift;
  
      return $align =~ /\A(?:left|center|right)/;
  }
  
  sub _parse_spec {
      my $spec = shift;
  
      if (!defined($spec))
      {
          $spec = '';
      }
  
      my $alispec = qr/^ *(?:left|center|right|num|point|auto)/;
      my ( $title, $align, $align_title, $align_title_lines, $sample);
      if ( ref eq 'HASH' ) {
          ( $title, $align, $align_title, $align_title_lines, $sample) =
              @{$spec}{qw( title align align_title align_title_lines sample )};
      } else {
          my $alispec = qr/&(.*)/;
          if ( $spec =~ $alispec ) {
              ($title, $align, $sample) = ($spec =~ /(.*)^$alispec\n?(.*)/sm);
          } else {
              $title = $spec;
          }
          defined and chomp for $title, $sample;
      }
  
      # Assign default values.
      foreach my $x ($title, $sample)
      {
          if (!defined($x))
          {
              $x = [];
          }
          elsif (ref($x) ne 'ARRAY')
          {
              $x = [ split /\n/, $x, -1];
          }
      }
  
      _default_if_empty(\$align, 'auto');
  
      unless (
          ref $align eq 'Regex' or
          $align =~ /^(?:left|center|right|num\(?|point\(?|auto)/
      ) {
          _warn( "Invalid align specification: '$align', using 'auto'");
          $align = 'auto';
      }
      
      _default_if_empty(\$align_title, 'left');
  
      if ( ! _is_align($align_title) ) {
          _warn( "Invalid align_title specification: " .
              "'$align_title', using 'left'",
          );
          $align_title = 'left';
      }
      
      _default_if_empty(\$align_title_lines, $align_title);
  
      if ( ! _is_align($align_title_lines) ) {
          _warn( "Invalid align_title_lines specification: " .
              "'$align_title_lines', using 'left'",
          );
          $align_title_lines = 'left';
      }
  
      return
      {
          title             => $title,
          align             => $align,
          align_title       => $align_title,
          align_title_lines => $align_title_lines,
          sample            => $sample,
      };
  }
  
  ### table creation
  
  sub new
  {
      my $tb = bless {}, shift;
  
      return $tb->_entitle( @_);
  }
  
  sub _blank
  {
      my $self = shift;
  
      if (@_)
      {
          $self->{blank} = shift;
      }
  
      return $self->{blank};
  }
  
  sub _cols
  {
      my $self = shift;
  
      if (@_)
      {
          $self->{cols} = shift;
      }
  
      return $self->{cols};
  }
  
  sub _forms
  {
      my $self = shift;
  
      if (@_)
      {
          $self->{forms} = shift;
      }
  
      return $self->{forms};
  }
  
  sub _lines
  {
      my $self = shift;
  
      if (@_)
      {
          $self->{lines} = shift;
      }
  
      return $self->{lines};
  }
  
  sub _spec
  {
      my $self = shift;
  
      if (@_)
      {
          $self->{spec} = shift;
      }
  
      return $self->{spec};
  }
  
  sub _titles
  {
      my $self = shift;
  
      if (@_)
      {
          $self->{titles} = shift;
      }
  
      return $self->{titles};
  }
  
  sub _entitle {
      my $tb = shift; # will be completely overwritten
      # find active separators and, well separate them from col specs.
      # n+1 separators for n cols
      my ( @seps, @spec); # separators and column specifications
      my $sep;
      for ( @_ ) {
          if ( _is_sep ( $_) ) {
              $sep = _parse_sep( $_);
          } else {
              push @seps, $sep;
              push @spec, _parse_spec( $_);
              undef $sep;
          }
      }
      push @seps, $sep;
      # build sprintf formats from separators
      my $title_form = _compile_field_format('title', \@seps);
      my $body_form = _compile_field_format('body', \@seps);
  
      # pre_align titles
      my @titles = map { [ @{ $_->{title} } ] } @spec;
  
      my $title_height = max(0, map { scalar(@$_) } @titles);
  
      foreach my $title (@titles)
      {
          push @{$title}, ( '') x ( $title_height - @{$title});
      }
  
      foreach my $t_idx (0 .. $#titles)
      {
          align($spec[$t_idx]->{align_title_lines}, @{$titles[$t_idx]});
      }
  
      # build data structure
      $tb->_spec(\@spec);
      $tb->_cols([ map [], 1 .. @spec]);
      $tb->_forms([ $title_form, $body_form]); # separators condensed
      $tb->_titles(\@titles);
  
      $tb->_clear_cache;
  
      return $tb;
  }
  
  # sprintf-format for line assembly, using separators
  sub _compile_format {
     my $seps = shift; # mix of strings and undef (for default)
  
     for my $idx (0 .. $#$seps)
     {
          if (!defined($seps->[$idx]))
          {
              $seps->[$idx] = ($idx == 0 or $idx == $#$seps) ? '' : q{ };
          }
          else
          {
              # protect against sprintf
              $seps->[$idx] =~ s/%/%%/g;
          }
     }
     return join '%s', @$seps;
  }
  
  sub _compile_field_format
  {
      my ($field, $seps) = @_;
  
      return _compile_format(
          [map { defined($_) ? $_->{$field} : undef } @$seps] 
      );
  }
  
  # reverse format compilation (used by colrange())
  sub _recover_separators {
      my $format = shift;
      my @seps = split /(?<!%)%s/, $format, -1;
      s/%%/%/g for @seps;
      return \@seps;
  }
  
  # select some columns, (optionally if in [...]), and add new separators
  # (the other table creator)
  sub select {
      my $tb = shift;
      my @args = map $tb->_select_group( $_), @_;
      # get column selection, checking indices (some have been checked by
      # _select_group, but not all)
      my @sel = map $tb->_check_index( $_), grep !_is_sep( $_), @args;
      # replace indices with column spec to create subtable
      for my $arg (@args)
      {
          if (! _is_sep($arg))
          {
              $arg = $tb->_spec->[ $arg];
          }
      }
      my $sub = ref( $tb)->new( @args);
      # sneak in data columns
      @{ $sub->{ cols}} = map { [ @$_ ] } @{ $tb->_cols}[ @sel];
      $sub;
  }
  
  # the first non-separator column in the group is tested if it has any data
  # if so, the group is returned, else nothing
  sub _select_group {
      my ( $tb, $group) = @_;
      return $_ unless ref $group eq 'ARRAY';
      for ( @$group ) {
          next if _is_sep( $_);
          $tb->_check_index( $_);
          return @$group if grep $_, @{ $tb->_cols->[ $_]};
          return; # no more tries after non-sep was found
      }
      return; # no column index in group, no select
  }
  
  # check index for validity, return arg if returns at all
  sub _check_index {
      my $tb = shift;
      my ( $i) = @_;
      my $n = $tb->n_cols;
      my $ok = eval {
          use warnings FATAL => 'numeric';
          -$n <= $i and $i < $n; # in range of column array?
      };
      _warn( "Invalid column index '$_'") if $@ or not $ok;
      shift;
  }
  
  ### data entry
  
  sub _clear_cache { 
      my ($tb) = @_;
      
      $tb->_blank(undef());
      $tb->_lines(undef());
  
      return;
  }
  
  # add one data line or split the line into follow-up lines
  sub add {
      my $tb = shift;
      $tb->_entitle( ( '') x @_) unless $tb->n_cols;
  
      $tb->_add( @$_) for 
          _transpose( 
              [
                  map { [ defined() ? split( /\n/ ) : '' ] } @_
              ]
          );
      $tb->_clear_cache;
  
      return $tb;
  }   
  
  # add one data line
  sub _add {
      my $tb = shift;
  
      push @$_, shift for @{ $tb->_cols};
  
      $tb->_clear_cache;
  
      return $tb;
  }
  
  # add one or more data lines
  sub load {
      my $tb = shift;
      for ( @_ ) {
          defined $_ or $_ = '';
          ref eq 'ARRAY' ? $tb->add( @$_) : $tb->add( split);
      }
      $tb;
  }
  
  sub clear {
      my $tb = shift;
  
      foreach my $col (@{ $tb->_cols} )
      {
          $col = [];
      }
  
      $tb->_clear_cache;
  
      return $tb;
  }
  
  ### access to output area
  
  ## sizes
  
  # number of table clolumns
  sub n_cols { scalar @{ $_[0]->{ spec}} }
  
  # number of title lines
  sub title_height { $_[ 0]->n_cols and scalar @{ $_[ 0]->_titles->[ 0]} }
  
  # number of data lines
  sub body_height
  { 
      my ($tb) = @_;
  
      return ($tb->n_cols && scalar @{ $tb->_cols->[0] });
  }
  
  # total height
  sub table_height
  { 
      my $tb = shift;
      return $tb->title_height + $tb->body_height;
  }
  
  BEGIN { *height = \&table_height; } # alias
  
  # number of characters in each table line. need to build the table to know
  sub width
  {
      my ($tb) = @_;
  
      return $tb->height && (length( ($tb->table(0))[0] ) - 1);
  }
  
  sub _normalize_col_index
  {
      my ($tb, $col_index) = @_;
  
      $col_index ||= 0;
  
      if ($col_index < 0)
      {
          $col_index += $tb->n_cols;
      }
  
      if ($col_index < 0)
      {
          $col_index = 0;
      }
      elsif ($col_index > $tb->n_cols)
      {
          $col_index = $tb->n_cols;
      }
  
      return $col_index;
  }
  
  # start and width of each column
  sub colrange {
      my ( $tb, $proto_col_index) = @_;
  
      my $col_index = $tb->_normalize_col_index($proto_col_index);
  
      return ( 0, 0) unless $tb->width; # width called, $tb->_blank() exists now
      my @widths = map { length } @{ $tb->_blank}, '';
      @widths = @widths[ 0 .. $col_index];
  
      my $width = pop @widths;
      my $pos = sum(@widths) || 0;
  
      my $seps_aref = _recover_separators( $tb->_forms->[ 0]);
  
      my $sep_sum = 0;
      foreach my $sep (@$seps_aref[ 0 .. $col_index])
      {
          $sep_sum += length($sep);
      }
  
      return ( $pos+$sep_sum, $width ) ;
  }
  
  ## printable output
  
  # whole table
  sub table {
      my $tb = shift;
  
      return $tb->_table_portion( $tb->height, 0, @_);
  }
  
  # only titles
  sub title {
      my $tb = shift;
  
      return $tb->_table_portion( $tb->title_height, 0, @_);
  }   
  
  # only body
  sub body {
      my $tb = shift;
  
      return $tb->_table_portion( $tb->body_height, $tb->title_height, @_);
  }
  
  sub stringify
  { 
      my ($tb) = @_;
  
      return (scalar ( $tb->table() ));
  }
  
  ### common internals
  
  # common representation of table(), title() and body()
  
  sub _table_portion_as_aref
  {
      my $tb = shift;
  
      my $total = shift;
      my $offset = shift;
  
      my ( $from, $n) = ( 0, $total); # if no parameters
  
      if ( @_ ) {
          $from = shift;
          $n = @_ ? shift : 1; # one line if not given
      }
  
      ( $from, $n) = _limit_range( $total, $from, $n);
  
      my $limit = $tb->title_height; # title format below
      $from += $offset;
  
      return
      [
          map $tb->_assemble_line( $_ >= $limit, $tb->_table_line( $_), 0),
          $from .. $from + $n - 1
      ];
  }
  
  sub _table_portion
  {
      my $tb = shift;
  
      my $lines_aref = $tb->_table_portion_as_aref(@_);
  
      return (wantarray ? @$lines_aref : join('', @$lines_aref));
  }
  
  sub _limit_range
  {
      my ( $total, $from, $n) = @_;
  
      $from ||= 0;
      $from += $total if $from < 0;
      $n = $total unless defined $n;
  
      return ( 0, 0) if $from + $n < 0 or $from >= $total;
  
      $from = 0 if $from < 0;
      $n = $total - $from if $n > $total - $from;
  
      return( $from, $n);
  }
  
  # get table line (formatted, including titles). fill cache if needed
  sub _table_line {
      my ($tb, $idx) = @_;
  
      if (! $tb->_lines)
      {
          $tb->_lines([ $tb->_build_table_lines ]);
      }
  
      return $tb->_lines->[$idx];
  }
  
  # build array of lines of justified data items
  sub _build_table_lines {
      my $tb = shift;
  
      # copy data columns, replacing undef with ''
      my @cols =
          map
          { [ map { defined($_) ? $_ : '' } @$_ ] }
          @{ $tb->_cols() } ;
  
      # add set of empty strings for blank line (needed to build horizontal rules)
      foreach my $col (@cols)
      {
          push @$col, '';
      }
  
      # add samples for minimum alignment
      foreach my $col_idx (0 .. $#cols)
      {
          push @{$cols[$col_idx]}, @{$tb->_spec->[$col_idx]->{sample}};
      }
  
      # align to style
      foreach my $col_idx (0 .. $#cols)
      {
          align($tb->_spec->[$col_idx]->{align}, @{$cols[$col_idx]});
      }
  
      # trim off samples, but leave blank line
      foreach my $col (@cols)
      {
          splice( @{$col}, 1 + $tb->body_height );
      }
  
      # include titles
      foreach my $col_idx (0 .. $#cols)
      {
          unshift @{$cols[$col_idx]}, @{$tb->_titles->[$col_idx]};
      }
  
      # align title and body portions of columns
      # blank line will be there even with no data
      foreach my $col_idx (0 .. $#cols)
      {
          align($tb->_spec->[$col_idx]->{align_title}, @{$cols[$col_idx]});
      }
  
      # deposit a blank line, pulling it off the columns.
      # *_rule() knows this is done
      my @blank;
  
      foreach my $col (@cols)
      {
          push @blank, pop(@$col);
      }
  
      $tb->_blank(\@blank);
  
      return _transpose_n( $tb->height, \@cols); # bye-bye, @cols
  }
  
  # destructively transpose a number of lines/cols from an array of arrayrefs 
  sub _transpose_n {
      my ($n, $cols) = @_;
  
      return map { [ map { shift @$_ } @$cols] } 1 .. $n;
  }
  
  # like _transpose_n, but find the number to transpose from max of given
  sub _transpose
  {
      my ($cols) = @_;
  
      my $m = max ( map { scalar(@$_) } @$cols, []);
  
      return _transpose_n( $m, $cols);
  }
  
  # make a line from a number of formatted data elements
  sub _assemble_line {
      my ($tb, $in_body, $line_aref, $replace_spaces) = @_;
  
      my $format = $tb->_forms->[ !!$in_body];
  
      if ($replace_spaces)
      {
          $format =~ s/\s/=/g;
      }
  
      return sprintf($format, @$line_aref) . "\n";
  }
  
  sub _text_rule
  {
      my ($tb, $rule, $char, $alt) = @_;
  
      # replace blanks with $char. If $alt is given, replace nonblanks
      # with $alt
      if ( defined $alt )
      {
          $rule =~ s/(.)/$1 eq ' ' ? $char : $alt/ge;
      }
      else
      {
          $rule =~ s/ /$char/g if $char ne ' ';
      }
  
      return $rule;
  }
  
  # build a rule line
  sub _rule {
      my $tb = shift;
  
      return + (!$tb->width) ? '' : $tb->_positive_width_rule(@_);
  }
  
  sub _positive_width_rule
  {
      my ($tb, $in_body, $char, $alt) = @_;
  
      my $rule = $tb->_assemble_line( $in_body, $tb->_blank,
          ((ref($char) eq "CODE") ? 1 : 0),
      );
  
      return $tb->_render_rule($rule, $char, $alt);
  }
  
  sub _render_rule
  {
      my ($tb, $rule, $char, $alt) = @_;
  
      if (ref($char) eq "CODE")
      {
          return $tb->_render_rule_with_callbacks($rule, $char, $alt);
      }
      else
      {
          _default_if_empty(\$char, ' ');
  
          return $tb->_text_rule($rule, $char, $alt);
      }
  }
  
  sub _get_fixed_len_string
  {
      my ($s, $len) = @_;
  
      $s  = substr($s, 0, $len);
      $s .= ' ' x ($len - length($s));
  
      return $s;
  }
  
  sub _render_rule_with_callbacks
  {
      my ($tb, $rule, $char, $alt) = @_;
  
      my %callbacks =
      (
          'char' => { cb => $char, idx => 0, },
          'alt' => { cb => $alt, idx => 0, },
      );
  
      my $calc_substitution = sub {
          my $s = shift;
  
          my $len = length($s);
  
          my $which = (($s =~ /\A /) ? 'char' : 'alt');
          my $rec = $callbacks{$which};
  
          return _get_fixed_len_string(
              scalar ($rec->{cb}->($rec->{idx}++, $len)),
              $len,
          );
      };
  
      $rule =~ s/((.)\2*)/$calc_substitution->($1)/ge;
  
      return $rule;
  }
  
  sub rule {
      my $tb = shift;
      return $tb->_rule( 0, @_);
  }
  
  sub body_rule {
      my $tb = shift;
      return $tb->_rule( 1, @_);
  }
  
  ### warning behavior
  use Carp;
  
  {
      my ( $warn, $fatal) = ( 0, 0);
  
      sub warnings
      {
          # Ignore the class/object.
          my (undef, $toggle) = @_;
  
          $toggle ||= 'on';
          if ( $toggle eq 'off' )
          {
              ($warn, $fatal) = (0, 0);
          }
          elsif ( $toggle eq 'fatal' )
          {
              ($warn, $fatal) = (1, 1);
          }
          else
          {
              ($warn, $fatal) = (1, 0);
          }
          return $fatal ? 'fatal' : $warn ? 'on' : 'off';
      }
  
      sub _warn
      {
          my $msg = shift;
  
          return unless $warn;
  
          if ($fatal)
          {
              croak( $msg)
          }
  
          carp( $msg);
  
          return;
      }
  }
  
  __END__
  ########################################### main pod documentation begin ##
  
  =head1 NAME
  
  Text::Table - Organize Data in Tables
  
  =head1 SYNOPSIS
  
      use Text::Table;
      my $tb = Text::Table->new(
          "Planet", "Radius\nkm", "Density\ng/cm^3"
      );
      $tb->load(
          [ "Mercury", 2360, 3.7 ],
          [ "Venus", 6110, 5.1 ],
          [ "Earth", 6378, 5.52 ],
          [ "Jupiter", 71030, 1.3 ],
      );
      print $tb;
  
  This prints a table from the given title and data like this:
  
    Planet  Radius Density
            km     g/cm^3 
    Mercury  2360  3.7    
    Venus    6110  5.1    
    Earth    6378  5.52   
    Jupiter 71030  1.3    
  
  Note that two-line titles work, and that the planet names are aligned
  differently than the numbers.
  
  =head1 DESCRIPTION
  
  Organization of data in table form is a time-honored and useful
  method of data representation.  While columns of data are trivially
  generated by computer through formatted output, even simple tasks
  like keeping titles aligned with the data columns are not trivial,
  and the one-shot solutions one comes up with tend to be particularly
  hard to maintain.  Text::Table allows you to create and maintain
  tables that adapt to alignment requirements as you use them.
  
  =head2 Overview
  
  The process is simple: you create a table (a Text::Table object) by
  describing the columns the table is going to have.  Then you load
  lines of data into the table, and finally print the resulting output
  lines.  Alignment of data and column titles is handled dynamically
  in dependence on the data present.
  
  =head2 Table Creation
  
  In the simplest case, if all you want is a number of (untitled) columns,
  you create an unspecified table and start adding data to it.  The number
  of columns is taken from the first line of data.
  
  To specify a table you specify its columns.  A column description
  can contain a title and alignment requirements for the data, both
  optional.  Additionally, you can specify how the title is aligned with
  the body of a column, and how the lines of a multiline title are
  aligned among themselves.
  
  The columns are collected in the table in the
  order they are given.  On data entry, each column corresponds to
  one data item, and in column selection columns are indexed left to
  right, starting from 0.
  
  Each title can be a multiline string which will be blank-filled to
  the length of the longest partial line.  The largest number of title
  lines in a column determines how many title lines the table has as a
  whole, including the case that no column has any titles.
  
  On output, Columns are separated by a single blank.  You can control
  what goes between columns by specifying separators between (or before,
  or after) columns.  Separators don't contain any data and don't count
  in column indexing.  They also don't accumulate: in a sequence of only
  separators and no columns, only the last one counts.
  
  =head2 Status Information
  
  The width (in characters), height (in lines), number of columns, and
  similar data about the table is available.
  
  =head2 Data Loading
  
  Table data is entered line-wise, each time specifying data entries
  for all table columns.  A bulk loader for many lines at once is also
  available.  You can clear the data from the table for re-use (though
  you will more likely just create another table).
  
  Data can contain colorizing escape sequences (as provided by
  C<Term::AnsiColor>) without upsetting the alignment.
  
  =head2 Table Output
  
  The output area of a table is divided in the title and the body.
  
  The title contains the combined titles from the table columns, if
  any.  Its content never changes with a given table, but it may be
  spread out differently on the page through alignment with the data.
  
  The body contains the data lines, aligned column-wise as specified,
  and left-aligned with the column title.
  
  Each of these is arranged like a Perl array (counting from 0) and can
  be accessed in portions by specifying a first line and the number
  of following lines.  Also like an array, giving a negative first line
  counts from the end of the area.  The whole table, the title followed
  by the body, can also be accessed in this manner.
  
  The subdivisions are there so you can repeat the title (or parts of
  it) along with parts of the body on output, whether for screen paging
  or printout.
  
  A rule line is also available, which is the horizontal counterpart to
  the separator columns you specify with the table.
  It is basically a table line as it would appear if all data entries
  in the line were empty, that is, a blank line except for where the
  column separators have non-blank entries.  If you print it between
  data lines, it will not disrupt the vertical separator structure
  as a plain blank line would.  You can also request a solid rule
  consisting of any character, and even one with the non-blank column
  separators replaced by a character of your choice.  This way you can
  get the popular representation of line-crossings like so:
  
        |
    ----+---
        |
  
  =head2 Warning Control
  
  On table creation, some parameters are checked and warnings issued
  if you allow warnings.  You can also turn warnings into fatal errors.
  
  =head1 SPECIFICATIONS
  
  =head2 Column Specification
  
  Each column specification is a single scalar.  Columns can be either proper
  data columns or column separators.  Both can be specified either as
  (possibly multi-line) strings, or in a more explicit form as hash-refs.
  In the string form, proper columns are given as plain strings, and
  separators are given as scalar references to strings.  In hash form,
  separators have a true value in the field C<is_sep> while proper columns
  don't have this field.
  
  =over 4
  
  =item Columns as strings
  
  A column is given as a column title (any number of lines),
  optionally followed by alignment requirements.  Alignment requirements
  start with a line that begins with an ampersamd "&".  However, only the
  last such line counts as such, so if you have title lines that begin
  with "&", just append an ampersand on a line by itself as a dummy
  alignment section if you don't have one anyway.
  
  What follows the ampersand on its line is the alignment style (like
  I<left>, I<right>, ... as described in L<"Alignment">), you want for
  the data in this column.  If nothing follows, the general default I<auto>
  is used.  If you specify an invalid alignment style, it falls back to
  left alignment.
  
  The lines that follow can contain sample data for this column.  These
  are considered for alignment in the column, but never actually appear
  in the output.  The effect is to guarantee a minimum width for the
  column even if the current data doesn't require it.  This helps dampen
  the oscillations in the appearance of dynamically aligned tables.
  
  =item Columns as Hashes
  
  The format is
  
      {
          title   => $title,
          align   => $align,
          sample  => $sample,
          align_title => $align_title,
          align_title_lines => $align_title_lines,
      }
  
  $title contains the title lines and $sample the sample data.  Both can
  be given as a string or as an array-ref to the list of lines.  $align contains
  the alignment style (without a leading ampersand), usually as a string.
  You can also give a regular expression here, which specifies regex alignment.
  A regex can only be specified in the hash form of a colunm specification.
  
  In hash form you can also specify how the title of a column is aligned
  with its body.  To do this, you specify the keyword C<align_title> with
  C<left>, C<right> or C<center>.  Other alignment specifications are not
  valid here.  The default is C<left>.
  
  C<align_title> also specifies how the lines of a multiline title are
  aligned among themselves.  If you want a different alignment, you
  can specify it with the key C<align_title_lines>.  Again, only C<left>,
  C<right> or C<center> are allowed.
  
  Do not put other keys than those mentioned above (I<title>, I<align>,
  I<align_title>, I<align_title_lines>, and I<sample>) into a hash that
  specifies a column.  Most would be ignored, but some would confuse the
  interpreter (in particular, I<is_sep> has to be avoided).
  
  =item Separators as strings
  
  A separator must be given as a reference to a string (often a literal,
  like C<\' | '>), any string that is given directly describes a column.
  
  It is usually just a (short) string that will be printed between
  table columns on all table lines instead of the default single
  blank.  If you specify two separators (on two lines), the first one
  will be used in the title and the other in the body of the table.
  
  =item Separators as Hashes
  
  The hash representation of a separator has the format
  
      {
          is_sep => 1,
          title  => $title,
          body   => $body,
      }
  
  $title is the separator to be used in the title area and $body
  the one for the body.  If only one is given, the other is used for
  both.  If none is given, a blank is used.  If one is shorter than
  the other, it is blank filled on the right.
  
  The value of C<is_sep> must be set to a true value, this is the
  distinguishing feature of a separator.
  
  =back
  
  =head2 Alignment
  
  The original documentation to L<Text::Aligner> contains all the details
  on alignment specification, but here is the rundown:
  
  The possible alignment specifications are I<left>, I<right>, I<center>,
  I<num> and I<point> (which are synonyms), and I<auto>.  The first
  three explain themselves.
  
  I<num> (and I<point>) align the decimal point in the data, which is
  assumed to the right if none is present.  Strings that aren't
  numbers are treated the same way, that is, they appear aligned
  with the integers unless they contain a ".".  Instead of the
  decimal point ".", you can also specify any other string in
  the form I<num(,)>, for instance.  The string in parentheses
  is aligned in the data.  The synonym I<point> for I<num> may be
  more appropriate in contexts that deal with arbitrary
  strings, as in I<point(=E<gt>)> (which might be used to align certain
  bits of Perl code).
  
  I<regex alignment> is a more sophisticated form of point alignment.
  If you specify a regular expression, as delivered by C<qr//>, the start
  of the match is used as the alignment point.  If the regex contains
  capturing parentheses, the last submatch counts.  [The usefulness of
  this feature is under consideration.]
  
  I<auto> alignment combines numeric alignment with left alignment.
  Data items that look like numbers, and those that don't, form two
  virtual columns and are aligned accordingly: C<num> for numbers and
  C<left> for other strings.  These columns are left-aligned with
  each other (i.e. the narrower one is blank-filled) to form the 
  final alignment.
  
  This way, a column that happens to have only numbers in the data gets
  I<num> alignment, a column with no numbers appears I<left>-aligned,
  and mixed data is presented in a reasonable way.
  
  =head2 Column Selection
  
  Besides creating tables from scratch, they can be created by
  selecting columns from an existing table.  Tables created this
  way contain the data from the columns they were built from.
  
  This is done by specifying the columns to select by their index
  (where negative indices count backward from the last column).
  The same column can be selected more than once and the sequence
  of columns can be arbitrarily changed.  Separators don't travel
  with columns, but can be specified between the columns at selection
  time.
  
  You can make the selection of one or more columns dependent on
  the data content of one of them.  If you specify some of the columns
  in angle brackets [...], the whole group is only included in the
  selection if the first column in the group contains any data that
  evaluates to boolean true.  That way you can de-select parts of a
  table if it contains no interesting data.  Any column separators
  given in brackets are selected or deselected along with the rest
  of it.
  
  =head1 PUBLIC METHODS
  
  =head2 Table Creation
  
  =over 4
  
  =item new()
  
      my $tb = Text::Table->new( $column, ... );
  
  creates a table with the columns specified.  A column can be proper column
  which contains and displays data, or a separator which tells how to fill
  the space between columns.  The format of the parameters is described under
  L<"Column Specification">. Specifying an invalid alignment for a column
  results in a warning if these are allowed.
  
  If no columns are specified, the number of columns is taken from the first
  line of data added to the table.  The effect is as if you had specified
  C<Text::Table-E<gt>new( ( '') x $n)>, where C<$n> is the number of
  columns.
  
  =item select()
  
      my $sub = $tb->select( $column, ...);
  
  creates a table from the listed columns of the table $tb, including
  the data.  Columns are specified as integer indices which refer to
  the data columns of $tb.  Columns can be repeated and specified in any
  order.  Negative indices count from the last column.  If an invalid
  index is specified, a warning is issued, if allowed.
  
  As with L<"new()">, separators can be interspersed among the column
  indices and will be used between the columns of the new table.
  
  If you enclose some of the arguments (column indices or separators) in
  angle brackets C<[...]> (technically, you specify them inside an
  arrayref), they form a group for conditional selection.  The group is
  only included in the resulting table if the first actual column inside
  the group contains any data that evaluate to a boolean true.  This way
  you can exclude groups of columns that wouldn't contribute anything
  interesting.  Note that separators are selected and de-selected with
  their group.  That way, more than one separator can appear between
  adjacent columns.  They don't add up, but only the rightmost separator
  is used.  A group that contains only separators is never selected.
  [Another feature whose usefulness is under consideration.]
  
  =back
  
  =head2 Status Information
  
  =over 4
  
  =item n_cols()
  
      $tb->n_cols
  
  returns the number of columns in the table.
  
  =item width()
  
      $tb->width
  
  returns the width (in characters) of the table.  All table lines have
  this length (not counting a final "\n" in the line), as well as the
  separator lines returned by $tb->rule() and $b->body_rule().
  The width of a table can potentially be influenced by any data item
  in it.
  
  =item height()
  
      $tb->height
  
  returns the total number of lines in a table, including title lines
  and body lines. For orthogonality, the synonym table_height() also
  exists.
  
  =item table_height()
  
  Same as C<< $table->height() >>.
  
  =item title_height()
  
      $tb->title_height
  
  returns the number of title lines in a table.
  
  =item body_height()
  
      $tb->body_height
  
  returns the number of lines in the table body.
  
  =item colrange()
  
      $tb->colrange( $i)
  
  returns the start position and width of the $i-th column (counting from 0)
  of the table.  If $i is negative, counts from the end of the table.  If $i
  is larger than the greatest column index, an imaginary column of width 0
  is assumed right of the table.
  
  =back
  
  =head2 Data Loading
  
  =over 4
  
  =item add()
  
      $tb->add( $col1, ..., $colN)
  
  adds a data line to the table, returns the table.
  
  C<$col1>, ..., C<$colN> are scalars that
  correspond to the table columns.  Undefined entries are converted to '',
  and extra data beyond the number of table columns is ignored.
  
  Data entries can be multi-line strings.  The partial strings all go into
  the same column.  The corresponding fields of other columns remain empty
  unless there is another multi-line entry in that column that fills the
  fieds.  Adding a line with multi-line entries is equivalent to adding
  multiple lines.
  
  Every call to C<add()> increases the body height of the table by the
  number of effective lines, one in the absence of multiline entries.
  
  =item load()
  
      $tb->load( $line, ...)
  
  loads the data lines given into the table, returns the table.
  
  Every argument to C<load()> represents a data line to be added to the
  table.  The line can be given as an array(ref) containing the data
  items, or as a string, which is split on whitespace to retrieve the
  data.  If an undefined argument is given, it is treated as an
  empty line.
  
  =item clear()
  
      $tb->clear;
  
  deletes all data from the table and resets it to the state after
  creation.  Returns the table.  The body height of a table is 0 after
  C<clear()>.
  
  =back
  
  =head2 Table Output
  
  The three methods C<table()>, C<title()>, and C<body()> are very similar.
  They access different parts of the printable output lines of a table with
  similar methods.  The details are described with the C<table()> method.
  
  =over 4
  
  =item table()
  
  The C<table()> method returns lines from the entire table, starting
  with the first title line and ending with the last body line.
  
  In array context, the lines are returned separately, in scalar context
  they are joined together in a single string.
  
      my @lines = $tb->table;
      my $line  = $tb->table( $line_number);
      my @lines = $tb->table( $line_number, $n);
  
  The first call returns all the lines in the table.  The second call
  returns one line given by $line_number.  The third call returns $n
  lines, starting with $line_number.  If $line_number is negative, it
  counts from the end of the array.  Unlike the C<select()> method,
  C<table()> (and its sister methods C<title()> and C<body()>) is
  protected against large negative line numbers, it truncates the
  range described by $line_number and $n to the existing lines.  If
  $n is 0 or negative, no lines are returned (an empty string in scalar
  context).
  
  =item stringify()
  
  Returns a string representation of the table. This method is called for
  stringification by overload.
  
      my @table_strings = map { $_->stringify() } @tables;
  
  =item title()
  
  Returns lines from the title area of a table, where the column titles
  are rendered.  Parameters and response to context are as with C<table()>,
  but no lines are returned from outside the title area.
  
  =item body()
  
  Returns lines from the body area of a table, that is the part where
  the data content is rendered, so that $tb->body( 0) is the first data
  line.  Parameters and response to context are as with C<table()>.
  
  =item rule()
  
      $tb->rule;
      $tb->rule( $char);
      $tb->rule( $char, $char1);
      $tb->rule( sub { my ($index, $len) = @_; }, 
                 sub { my ($index, $len) = @_; },
      );
  
  Returns a rule for the table.
  
  A rule is a line of table width that can be used between table lines
  to provide visual horizontal divisions, much like column separators
  provide vertical visual divisions.  In its basic form (returned by the
  first call) it looks like a table line with no data, hence a blank
  line except for the non-blank parts of any column-separators.  If
  one character is specified (the second call), it replaces the blanks
  in the first form, but non-blank column separators are retained.  If
  a second character is specified, it replaces the non-blank parts of
  the separators.  So specifying the same character twice gives a solid
  line of table width.  Another useful combo is C<$tb-E<lt>rule( '-', '+')>,
  together with separators that contain a single nonblank "|", for a
  popular representation of line crossings.
  
  C<rule()> uses the column separators for the title section if there
  is a difference.
  
  If callbacks are specified instead of the characters, then they receive the
  index of the section of the rule they need to render and its desired length in
  characters, and should return the string to put there. The indexes given
  are 0 based (where 0 is either the left column separator or the leftmost
  cell) and the strings will be trimmed or extended in the replacement.
  
  =item body_rule()
  
  C<body_rule()> works like <rule()>, except the rule is generated using
  the column separators for the table body.
  
  =back
  
  =head2 Warning Control
  
  =over 4
  
  =item warnings()
  
      Text::Table->warnings();
      Text::Table->warnings( 'on');
      Text::Table->warnings( 'off'):
      Text::Table->warnings( 'fatal'):
  
  The C<warnings()> method is used to control the appearance of warning
  messages while tables are manipulated.  When Text::Table starts, warnings
  are disabled.  The default action of C<warnings()> is to turn warnings
  on.  The other possible arguments are self-explanatory.  C<warnings()>
  can also be called as an object method (C<$tb-E<gt>warnings( ...)>).
  
  =back
  
  =head1 VERSION
      
  This document pertains to Text::Table version 1.121
  
  =head1 BUGS
  
  =over 4
  
  =item o
  
  I<auto> alignment doesn't support alternative characters for the decimal
  point.  This is actually a bug in the underlying Text::Aligner by the
  same author.
  
  =back
  
  =head1 AUTHOR
  
  =head2 MAINTAINER
  
  Shlomi Fish, L<http://www.shlomifish.org/> - CPAN ID: "SHLOMIF".
  
  =head2 ORIGINAL AUTHOR
  
      Anno Siegel
      CPAN ID: ANNO 
      siegel@zrz.tu-berlin.de
      http://www.tu-berlin.de/~siegel
  
  =head1 COPYRIGHT
  
  Copyright (c) 2002 Anno Siegel. All rights reserved.
  This program is free software; you can redistribute
  it and/or modify it under the terms of the ISC license.
  
  (This program had been licensed under the same terms as Perl itself up to
  version 1.118 released on 2011, and was relicensed by permission of its
  originator).
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =head1 SEE ALSO
  
  L<Text::Aligner>, L<perl(1)> .
  
  =cut
  
  1;
TEXT_TABLE

s/^  //mg for values %fatpacked;

unshift @INC, sub {
  if (my $fat = $fatpacked{$_[1]}) {
    open my $fh, '<', \$fat
      or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
    return $fh;
  }
  return
};

} # END OF FATPACK CODE

use strict;
use App::llenv;

unless (caller) {
    my $app = App::llenv->new;
    $app->init;
    $app->parse_options(@ARGV);
    $app->run or exit(1);
}

__END__
